'use strict';

var helpers = require('./helpers-bVbODwYf.js');
var vue = require('vue');

var _PatchFlagNames, _slotFlagsText;
!!(process.env.NODE_ENV !== "production") ? Object.freeze({}) : {};
!!(process.env.NODE_ENV !== "production") ? Object.freeze([]) : [];
var cacheStringFunction = function cacheStringFunction(fn) {
  var cache = /* @__PURE__ */Object.create(null);
  return function (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : "";
  });
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(function (str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
});
var capitalize = cacheStringFunction(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var toHandlerKey = cacheStringFunction(function (str) {
  var s = str ? "on".concat(capitalize(str)) : "";
  return s;
});
(_PatchFlagNames = {}, helpers._defineProperty(_PatchFlagNames, 1, "TEXT"), helpers._defineProperty(_PatchFlagNames, 2, "CLASS"), helpers._defineProperty(_PatchFlagNames, 4, "STYLE"), helpers._defineProperty(_PatchFlagNames, 8, "PROPS"), helpers._defineProperty(_PatchFlagNames, 16, "FULL_PROPS"), helpers._defineProperty(_PatchFlagNames, 32, "HYDRATE_EVENTS"), helpers._defineProperty(_PatchFlagNames, 64, "STABLE_FRAGMENT"), helpers._defineProperty(_PatchFlagNames, 128, "KEYED_FRAGMENT"), helpers._defineProperty(_PatchFlagNames, 256, "UNKEYED_FRAGMENT"), helpers._defineProperty(_PatchFlagNames, 512, "NEED_PATCH"), helpers._defineProperty(_PatchFlagNames, 1024, "DYNAMIC_SLOTS"), helpers._defineProperty(_PatchFlagNames, 2048, "DEV_ROOT_FRAGMENT"), helpers._defineProperty(_PatchFlagNames, -1, "HOISTED"), helpers._defineProperty(_PatchFlagNames, -2, "BAIL"), _PatchFlagNames);
(_slotFlagsText = {}, helpers._defineProperty(_slotFlagsText, 1, "STABLE"), helpers._defineProperty(_slotFlagsText, 2, "DYNAMIC"), helpers._defineProperty(_slotFlagsText, 3, "FORWARDED"), _slotFlagsText);

var SlotComponent = {
  name: 'BSlotComponent',
  props: {
    component: {
      type: Object,
      required: true
    },
    name: {
      type: String,
      "default": 'default'
    },
    scoped: {
      type: Boolean
    },
    props: {
      type: Object
    },
    tag: {
      type: String,
      "default": 'div'
    },
    event: {
      type: String,
      "default": 'vue:updated'
    }
  },
  data: function data() {
    return {
      updatedHook: undefined,
      handlerKey: undefined
    };
  },
  methods: {
    refresh: function refresh() {
      this.$forceUpdate();
    }
  },
  created: function created() {
    if (helpers.isVueComponent(this.component)) {
      if (this.event === 'vue:updated') {
        // lifecycle event cannot be captured as an ordinary event
        this.updatedHook = vue.onUpdated(this.refresh, this.component.$);
      } else {
        // directly manipuates the VNode
        // because Vue 3 no longer provides $on
        var vnode = this.component.$.vnode;
        var handlerKey = toHandlerKey(this.event);
        if (vnode.props == null) {
          vnode.props = helpers._defineProperty({}, handlerKey, this.refresh);
        } else {
          var props = vnode.props;
          if (props[this.handlerKey] == null) {
            // tries camelCase
            handlerKey = toHandlerKey(camelize(this.event));
            if (props[handlerKey] == null) {
              // tries kebab-case
              handlerKey = toHandlerKey(hyphenate(this.event));
            }
          }
          if (props[handlerKey] == null) {
            handlerKey = toHandlerKey(this.event);
            props[handlerKey] = this.refresh;
          } else {
            // multiple handlers may be specified in an array
            if (Array.isArray(props[handlerKey])) {
              props[handlerKey].push(this.refresh);
            } else {
              props[handlerKey] = [props[handlerKey], this.refresh];
            }
          }
        }
        this.handlerKey = handlerKey;
      }
    }
  },
  beforeUnmount: function beforeUnmount() {
    if (helpers.isVueComponent(this.component)) {
      if (this.updatedHook != null) {
        // unfortunately, there is no counterpart of `onUpdated`.
        // so directly manipulates the internal instance.
        // see https://github.com/vuejs/core/blob/2ffe3d5b3e953b63d4743b1e2bc242d50916b545/packages/runtime-core/src/apiLifecycle.ts#L17-L64
        var index = this.component.$.u.indexOf(this.updatedHook);
        if (index !== -1) {
          this.component.$.u.splice(index, 1);
        }
      } else if (this.handlerKey != null) {
        // directly maniputates VNode
        // because Vue 3 no longer provides $off
        var props = this.component.$.vnode.props;
        if (props != null) {
          if (Array.isArray(props[this.handlerKey])) {
            var _index = props[this.handlerKey].indexOf(this.refresh);
            if (_index > -1) {
              props[this.handlerKey].splice(_index, 1);
              if (props[this.handlerKey].length === 1) {
                props[this.handlerKey] = props[this.handlerKey][0];
              }
            }
          } else {
            delete props[this.handlerKey];
          }
        }
      }
    }
  },
  render: function render() {
    return vue.h(this.tag, {}, this.component.$slots ? this.scoped ? this.component.$slots[this.name](this.props) : this.component.$slots[this.name]() : undefined);
  }
};

exports.SlotComponent = SlotComponent;
