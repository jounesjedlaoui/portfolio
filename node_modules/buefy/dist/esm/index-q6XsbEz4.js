import { F as FormElementMixin } from './FormElementMixin-ILDlgM3i.js';
import { c as isMobile } from './helpers-O9h6_ICO.js';
import { c as config } from './config-nHWiBviw.js';
import { _ as _typeof } from './typeof-Z4rCTFCZ.js';
import { _ as _createClass, a as _classCallCheck } from './classCallCheck-E4khD9xn.js';
import { s as script$9, a as script$a } from './DropdownItem-yQcaSZL4.js';
import { s as script$5 } from './Input-0ivJhXUC.js';
import { s as script$6 } from './Field-CMd66v8h.js';
import { s as script$7 } from './Select-DY-wGhZc.js';
import { s as script$8 } from './Icon-fJqkx1gN.js';
import { openBlock, createElementBlock, createElementVNode, withModifiers, normalizeStyle, resolveComponent, createVNode, withCtx, createTextVNode, normalizeClass, createBlock, createSlots, renderSlot, createCommentVNode, toDisplayString } from 'vue';
import { s as script$4 } from './Tooltip-WHq2LJas.js';
import { u as use, a as registerComponent } from './plugins-1raZX6c5.js';

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn === "function";
  }
}

function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var colorChannels = ['red', 'green', 'blue', 'alpha'];
var colorsNammed = {
  transparent: '#00000000',
  black: '#000000',
  silver: '#c0c0c0',
  gray: '#808080',
  white: '#ffffff',
  maroon: '#800000',
  red: '#ff0000',
  purple: '#800080',
  fuchsia: '#ff00ff',
  green: '#008000',
  lime: '#00ff00',
  olive: '#808000',
  yellow: '#ffff00',
  navy: '#000080',
  blue: '#0000ff',
  teal: '#008080',
  aqua: '#00ffff',
  orange: '#ffa500',
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  blanchedalmond: '#ffebcd',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkgrey: '#a9a9a9',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkslategrey: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  gold: '#ffd700',
  goldenrod: '#daa520',
  greenyellow: '#adff2f',
  grey: '#808080',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavender: '#e6e6fa',
  lavenderblush: '#fff0f5',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgray: '#d3d3d3',
  lightgreen: '#90ee90',
  lightgrey: '#d3d3d3',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightslategrey: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370db',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  oldlace: '#fdf5e6',
  olivedrab: '#6b8e23',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#db7093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  whitesmoke: '#f5f5f5',
  yellowgreen: '#9acd32',
  rebeccapurple: '#663399'
};
var ColorTypeError = /*#__PURE__*/function (_Error) {
  _inherits(ColorTypeError, _Error);
  var _super = _createSuper(ColorTypeError);
  function ColorTypeError() {
    _classCallCheck(this, ColorTypeError);
    return _super.call(this, 'ColorTypeError: type must be hex(a), rgb(a) or hsl(a)');
  }
  return _createClass(ColorTypeError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var Color = /*#__PURE__*/function (_Symbol$toString) {
  function Color() {
    var _this = this;
    _classCallCheck(this, Color);
    if (arguments.length > 0) {
      return Color.parse.apply(Color, arguments);
    }
    this.$channels = new Uint8Array(colorChannels.length);
    colorChannels.forEach(function (channel, index) {
      Object.defineProperty(_this, channel, {
        get: function get() {
          return _this.$channels[index];
        },
        set: function set(_byte) {
          if (!Number.isNaN(_byte / 1)) {
            _this.$channels[index] = Math.min(255, Math.max(0, _byte));
          }
        },
        enumerable: true,
        configurable: true
      });
    })
    // Required for observability
    ;
    ['hue', 'saturation', 'lightness'].forEach(function (name) {
      var capitalizedName = name.replace(/^./, function (m) {
        return m.toUpperCase();
      });
      Object.defineProperty(_this, name, {
        get: function get() {
          return _this["get".concat(capitalizedName)]();
        },
        set: function set(value) {
          if (!Number.isNaN(value / 1)) {
            _this["set".concat(capitalizedName)](value);
          }
        },
        enumerable: true,
        configurable: true
      });
    });
  }
  _createClass(Color, [{
    key: "getHue",
    value: function getHue() {
      var _Array$from$map = Array.from(this.$channels).map(function (c) {
          return c / 255;
        }),
        _Array$from$map2 = _slicedToArray(_Array$from$map, 3),
        red = _Array$from$map2[0],
        green = _Array$from$map2[1],
        blue = _Array$from$map2[2];
      var _ref = [Math.min(red, green, blue), Math.max(red, green, blue)],
        min = _ref[0],
        max = _ref[1];
      var delta = max - min;
      var hue = 0;
      if (delta === 0) {
        return hue;
      }
      if (red === max) {
        hue = (green - blue) / delta % 6;
      } else if (green === max) {
        hue = (blue - red) / delta + 2;
      } else {
        hue = (red - green) / delta + 4;
      }
      hue *= 60;
      while (hue !== -Infinity && hue < 0) hue += 360;
      return Math.round(hue % 360);
    }
  }, {
    key: "setHue",
    value: function setHue(value) {
      var color = Color.fromHSL(value, this.saturation, this.lightness, this.alpha / 255);
      for (var i = 0; i < this.$channels.length; i++) {
        this.$channels[i] = Number(color.$channels[i]);
      }
    }
  }, {
    key: "getSaturation",
    value: function getSaturation() {
      var _Array$from$map3 = Array.from(this.$channels).map(function (c) {
          return c / 255;
        }),
        _Array$from$map4 = _slicedToArray(_Array$from$map3, 3),
        red = _Array$from$map4[0],
        green = _Array$from$map4[1],
        blue = _Array$from$map4[2];
      var _ref2 = [Math.min(red, green, blue), Math.max(red, green, blue)],
        min = _ref2[0],
        max = _ref2[1];
      var delta = max - min;
      return delta !== 0 ? Math.round(delta / (1 - Math.abs(2 * this.lightness - 1)) * 100) / 100 : 0;
    }
  }, {
    key: "setSaturation",
    value: function setSaturation(value) {
      var _this2 = this;
      var color = Color.fromHSL(this.hue, value, this.lightness, this.alpha / 255);
      colorChannels.forEach(function (_, i) {
        return _this2.$channels[i] = color.$channels[i];
      });
    }
  }, {
    key: "getLightness",
    value: function getLightness() {
      var _Array$from$map5 = Array.from(this.$channels).map(function (c) {
          return c / 255;
        }),
        _Array$from$map6 = _slicedToArray(_Array$from$map5, 3),
        red = _Array$from$map6[0],
        green = _Array$from$map6[1],
        blue = _Array$from$map6[2];
      var _ref3 = [Math.min(red, green, blue), Math.max(red, green, blue)],
        min = _ref3[0],
        max = _ref3[1];
      return Math.round((max + min) / 2 * 100) / 100;
    }
  }, {
    key: "setLightness",
    value: function setLightness(value) {
      var _this3 = this;
      var color = Color.fromHSL(this.hue, this.lightness, value, this.alpha / 255);
      colorChannels.forEach(function (_, i) {
        return _this3.$channels[i] = color.$channels[i];
      });
    }
  }, {
    key: "clone",
    value: function clone() {
      var _this4 = this;
      var color = new Color();
      colorChannels.forEach(function (_, i) {
        return color.$channels[i] = _this4.$channels[i];
      });
      return color;
    }
  }, {
    key: "toString",
    value: function toString() {
      var _this5 = this;
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hex';
      switch (String(type).toLowerCase()) {
        case 'hex':
          return '#' + colorChannels.slice(0, 3).map(function (channel) {
            return _this5[channel].toString(16).padStart(2, '0');
          }).join('');
        case 'hexa':
          return '#' + colorChannels.map(function (channel) {
            return _this5[channel].toString(16).padStart(2, '0');
          }).join('');
        case 'rgb':
          return "rgb(".concat(this.red, ", ").concat(this.green, ", ").concat(this.blue, ")");
        case 'rgba':
          return "rgba(".concat(this.red, ", ").concat(this.green, ", ").concat(this.blue, ", ").concat(Math.round(this.alpha / 2.55) / 100, ")");
        case 'hsl':
          return "hsl(".concat(Math.round(this.hue), "deg, ").concat(Math.round(this.saturation * 100), "%, ").concat(Math.round(this.lightness * 100), "%)");
        case 'hsla':
          return "hsla(".concat(Math.round(this.hue), "deg, ").concat(Math.round(this.saturation * 100), "%, ").concat(Math.round(this.lightness * 100), "%, ").concat(Math.round(this.alpha / 2.55) / 100, ")");
        default:
          throw new ColorTypeError();
      }
    }
  }, {
    key: _Symbol$toString,
    get: function get() {
      return this.toString('hex');
    }
  }], [{
    key: "parse",
    value: function parse() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (_typeof(args[0]) === 'object') {
        return Color.parseObject(args[0]);
      } else if (args.every(function (arg) {
        return !Number.isNaN(arg / 1);
      })) {
        var color = new Color();
        if (args.length > 3) {
          color.red = args[0];
          color.green = args[1];
          color.blue = args[2];
          if (args[3]) {
            color.alpha = args[3];
          }
        } else if (args.length === 1) {
          var index = Number(args[0]);
          return Color.parseIndex(index, index > Math.pow(2, 24) ? 3 : 4);
        }
      } else if (typeof args[0] === 'string') {
        var match = null;
        if (typeof colorsNammed[args[0].toLowerCase()] === 'string') {
          return Color.parseHex(colorsNammed[args[0].toLowerCase()]);
        } else if ((match = args[0].match(/^(#|&h|0x)?(([a-f0-9]{3,4}){1,2})$/i)) !== null) {
          return Color.parseHex(match[2]);
        } else if ((match = args[0].match(/^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(\s*,\s*(\d*\.?\d+))?\s*\)$/i)) !== null) {
          var channels = [match[1], match[2], match[3], typeof match[5] !== 'undefined' ? match[5] : 1];
          return Color.fromRGB.apply(Color, _toConsumableArray(channels.map(function (value) {
            return Number(value);
          })));
        } else if (args[0].match(/^(h(sl|wb)a?|lab|color|cmyk)\(/i)) {
          throw new Error('Color expression not implemented yet');
        }
      }
      throw new Error('Invalid color expression');
    }
  }, {
    key: "parseObject",
    value: function parseObject(object) {
      var color = new Color();
      if (object === null || _typeof(object) !== 'object') {
        return color;
      }
      if (Color.isColor(object)) {
        return object.clone();
      }
      colorChannels.forEach(function (channel) {
        if (!Number.isNaN(object[channel])) {
          color[channel] = object[channel];
        }
      });
      return color;
    }
  }, {
    key: "parseHex",
    value: function parseHex(hex) {
      if (typeof hex !== 'string') {
        throw new Error('Hex expression must be a string');
      }
      hex = hex.trim().replace(/^(0x|&h|#)/i, '');
      if (hex.length === 3 || hex.length === 4) {
        hex = hex.split('').map(function (c) {
          return c.repeat(2);
        }).join('');
      }
      if (!(hex.length === 6 || hex.length === 8)) {
        throw new Error('Incorrect Hex expression length');
      }
      var chans = hex.split(/(..)/).filter(function (value) {
        return value;
      }).map(function (value) {
        return Number.parseInt(value, 16);
      });
      if (typeof chans[3] === 'number') {
        chans[3] /= 255;
      }
      return Color.fromRGB.apply(Color, _toConsumableArray(chans));
    }
  }, {
    key: "parseIndex",
    value: function parseIndex(value) {
      var channels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
      var color = new Color();
      for (var i = 0; i < 4; i++) {
        color[colorChannels[i]] = value >> (channels - i) * 8 && 0xff;
      }
      return color;
    }
  }, {
    key: "fromRGB",
    value: function fromRGB(red, green, blue) {
      var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if ([red, green, blue, alpha].some(function (arg) {
        return Number.isNaN(arg / 1);
      })) {
        throw new Error('Invalid arguments');
      }
      alpha *= 255;
      var color = new Color();
      [red, green, blue, alpha].forEach(function (value, index) {
        color[colorChannels[index]] = value;
      });
      return color;
    }
  }, {
    key: "fromHSL",
    value: function fromHSL(hue, saturation, lightness) {
      var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      if ([hue, saturation, lightness, alpha].some(function (arg) {
        return Number.isNaN(arg);
      })) {
        throw new Error('Invalid arguments');
      }
      while (hue < 0 && hue !== -Infinity) hue += 360;
      hue = hue % 360;
      saturation = Math.max(0, Math.min(1, saturation));
      lightness = Math.max(0, Math.min(1, lightness));
      alpha = Math.max(0, Math.min(1, alpha));
      var c = (1 - Math.abs(2 * lightness - 1)) * saturation;
      var x = c * (1 - Math.abs(hue / 60 % 2 - 1));
      var m = lightness - c / 2;
      var _ref4 = hue < 60 ? [c, x, 0] : hue < 120 ? [x, c, 0] : hue < 180 ? [0, c, x] : hue < 240 ? [0, x, c] : hue < 300 ? [x, 0, c] : [c, 0, x],
        _ref5 = _slicedToArray(_ref4, 3),
        r = _ref5[0],
        g = _ref5[1],
        b = _ref5[2];
      return Color.fromRGB((r + m) * 255, (g + m) * 255, (b + m) * 255, alpha);
    }
  }, {
    key: "isColor",
    value: function isColor(arg) {
      return arg instanceof Color;
    }
  }]);
  return Color;
}(Symbol.toString);
var Color$1 = Color;

const cos30 = 0.86602540378;
const sin30 = 0.5;

let id = 0;

var script$3 = {
    name: 'BColorpickerHSLRepresentationTriangle',
    props: {
        value: {
            type: Object,
            required: true,
            validator(value) {
                return typeof value.hue === 'number' &&
                    typeof value.saturation === 'number' &&
                    typeof value.lightness === 'number'
            }
        },
        size: {
            type: Number,
            default: 200
        },
        thickness: {
            type: Number,
            default: 20
        }
    },
    emits: ['input'],
    data() {
        return {
            id: id++,
            hue: this.value.hue,
            saturation: this.value.saturation,
            lightness: this.value.lightness,
            captureMouse: false,
            captureType: 'hue',
            clientOffset: {
                cx: -1,
                cy: -1,
                width: 0,
                height: 0
            },
            cos30,
            sin30,
            debounce: 0
        }
    },
    computed: {
        viewBox() {
            const { size } = this;
            return `0 0 ${size} ${size}`
        },
        internalRadius() {
            return this.size / 2 - this.thickness
        },
        haloPath() {
            const { size, thickness } = this;
            const radius = size / 2 - 2; // 2px padding
            const thicknessRadius = radius - thickness;
            const center = size / 2;

            return `M${center - radius} ${center}a${radius}  ${radius}  0 1 1 ${2 * radius} 0` +
                `h${-thickness}` +
                `a${-thicknessRadius}  ${thicknessRadius}  0 1 0 ${-2 * thicknessRadius} 0` +
                `a${thicknessRadius}  ${thicknessRadius}  0 1 0 ${2 * thicknessRadius} 0` +
                `h${thickness}` +
                `a${radius}  ${radius}  0 1 1 ${-2 * radius} 0z`
        },
        trianglePath() {
            const { size, thickness } = this;
            const radius = size - 4;
            const thicknessRadius = (radius - 2 * thickness) / 2;

            return `M0 ${-thicknessRadius}` +
                `L${cos30 * thicknessRadius} ${sin30 * thicknessRadius}` +
                `H${-cos30 * thicknessRadius}z`
        }
    },
    watch: {
        captureMouse(newValue, oldValue) {
            if (oldValue === false && newValue !== false) {
                const rect = this.$el.getBoundingClientRect();
                // Caching offset
                this.clientOffset.cx = rect.x + rect.width / 2;
                this.clientOffset.cy = rect.y + rect.height / 2;
                this.clientOffset.width = rect.width;
                this.clientOffset.height = rect.height;
            }
        },
        value: {
            deep: true,
            handler(newColor) {
                const { hue, saturation, lightness } = newColor;

                window.clearTimeout(this.debounce);
                this.debounce = window.setTimeout(() => {
                    if (lightness >= 0.03 && lightness <= 0.97 && saturation > 0) {
                        this.hue = hue;
                    }
                    this.saturation = saturation;
                    this.lightness = lightness;
                }, 200);
            }
        }
    },
    methods: {
        increaseHue(value = 1) {
            this.hue = (this.hue + value) % 360;
        },
        decreaseHue(value = 1) {
            this.hue = (360 + this.hue - value) % 360;
        },
        increaseSaturation(value = 0.01) {
            this.saturation = Math.min(1, Math.max(0, this.saturation + value));
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness
                )
            );
        },
        decreaseSaturation(value = 0.01) {
            this.saturation = Math.min(1, Math.max(0, this.saturation - value));
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness
                )
            );
        },
        increaseLightness(value = 0.01) {
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness + value
                )
            );
        },
        decreaseLightness(value = 0.01) {
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness - value
                )
            );
        },
        hueKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                case 'ArrowUp':
                    this.increaseHue();
                    handled = true;
                    break
                case 'ArrowLeft':
                case 'ArrowDown':
                    this.decreaseHue();
                    handled = true;
                    break
                case 'Home':
                    this.increaseHue(360 - this.hue);
                    handled = true;
                    break
                case 'End':
                    this.decreaseHue(this.hue);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseHue(60 - this.hue % 60);
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseHue(60 + this.hue % 60);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitColor();
            }
        },
        slKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                    this.decreaseLightness();
                    handled = true;
                    break
                case 'ArrowUp':
                    this.increaseSaturation();
                    handled = true;
                    break
                case 'ArrowLeft':
                    this.increaseLightness();
                    handled = true;
                    break
                case 'ArrowDown':
                    this.decreaseSaturation();
                    handled = true;
                    break
                case 'Home':
                    this.increaseLightness(1 - this.lightness);
                    handled = true;
                    break
                case 'End':
                    this.decreaseLightness(this.lightness);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseSaturation(1 - this.saturation);
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseSaturation(this.saturation);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitColor();
            }
        },
        clickHue(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.hueCursor.focus();
        },
        clickSL(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.slCursor.focus();
        },
        trackMouse(event) {
            if (this.captureMouse === false) {
                return
            }
            event.preventDefault();
            event.stopPropagation();

            let [mouseX, mouseY] = [0, 0];
            if (typeof event.touches !== 'undefined' && event.touches.length) {
                [mouseX, mouseY] = [event.touches[0].clientX, event.touches[0].clientY];
            } else {
                [mouseX, mouseY] = [event.clientX, event.clientY];
            }
            const angle = Math.atan2(
                mouseY - this.clientOffset.cy,
                mouseX - this.clientOffset.cx
            );

            if (this.captureType === 'sl') {
                const d = Math.sqrt(
                    Math.pow(mouseX - this.clientOffset.cx, 2) +
                    Math.pow(mouseY - this.clientOffset.cy, 2)
                );
                const ratio = this.size / this.clientOffset.width;
                const dx = d * Math.cos(angle - this.hue / 180 * Math.PI) * ratio;
                const dy = d * Math.sin(angle - this.hue / 180 * Math.PI) * ratio;
                const radius = this.internalRadius;
                const saturation = 1 - (Math.min(
                    radius * sin30,
                    Math.max(
                        -radius,
                        dy
                    )
                ) + radius) / (radius + radius * sin30);
                const lightness = (Math.min(
                    (radius * cos30) * (1 - saturation),
                    Math.max(
                        (-radius * cos30) * (1 - saturation),
                        dx
                    )
                ) + radius * cos30) / (radius * 2 * cos30);

                this.saturation = Math.round(saturation * 1000) / 1000;
                this.lightness = 1 - Math.round(lightness * 1000) / 1000;
            } else {
                this.hue = Math.round(angle / Math.PI * 180 + 90) % 360;
            }
            this.emitColor();
        },
        startMouseCapture(event) {
            event.stopPropagation();

            this.captureMouse = true;
            if (event.target.closest('.colorpicker-triangle-slider-sl') !== null) {
                this.captureType = 'sl';
            } else {
                this.captureType = 'hue';
            }
        },
        stopMouseCapture(event) {
            if (this.captureMouse !== false) {
                event.preventDefault();
                event.stopPropagation();
                this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus();
            }
            this.captureMouse = false;
        },
        emitColor() {
            const { hue, saturation, lightness } = this;
            this.$emit('input', Color$1.fromHSL(hue, saturation, lightness));
            window.clearTimeout(this.debounce);
        }
    },
    mounted() {
        window.addEventListener('mousemove', this.trackMouse);
        window.addEventListener('touchmove', this.trackMouse, { passive: false });
        window.addEventListener('mouseup', this.stopMouseCapture);
        window.addEventListener('touchend', this.stopMouseCapture);
    },
    beforeUnmount() {
        window.removeEventListener('mousemove', this.trackMouse);
        window.removeEventListener('touchmove', this.trackMouse);
        window.removeEventListener('mouseup', this.stopMouseCapture);
        window.removeEventListener('touchend', this.stopMouseCapture);

        clearTimeout(this.debounce);
    }
};

const _hoisted_1$3 = ["viewBox"];
const _hoisted_2$1 = ["id"];
const _hoisted_3$1 = /*#__PURE__*/createElementVNode("stop", {
  offset: "0%",
  "stop-color": "#fff"
}, null, -1 /* HOISTED */);
const _hoisted_4$1 = /*#__PURE__*/createElementVNode("stop", {
  offset: "100%",
  "stop-color": "#000"
}, null, -1 /* HOISTED */);
const _hoisted_5 = [
  _hoisted_3$1,
  _hoisted_4$1
];
const _hoisted_6 = ["id"];
const _hoisted_7 = ["stop-color"];
const _hoisted_8 = ["stop-color"];
const _hoisted_9 = ["id"];
const _hoisted_10 = ["d"];
const _hoisted_11 = { class: "colorpicker-triangle-slider-hue" };
const _hoisted_12 = ["width", "height", "clip-path"];
const _hoisted_13 = ["x", "height"];
const _hoisted_14 = ["aria-valuenow"];
const _hoisted_15 = ["d", "fill"];
const _hoisted_16 = ["d", "fill"];
const _hoisted_17 = ["x", "y"];
const _hoisted_18 = ["aria-datavalues"];

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("svg", {
    viewBox: $options.viewBox,
    class: "b-colorpicker-triangle"
  }, [
    createElementVNode("defs", null, [
      createElementVNode("linearGradient", {
        id: `cp-triangle-gradient-ligthness-${$data.id}`,
        x1: "0",
        y1: "0",
        x2: "1",
        y2: "0"
      }, [..._hoisted_5], 8 /* PROPS */, _hoisted_2$1),
      createElementVNode("linearGradient", {
        id: `cp-triangle-gradient-saturation-${$data.id}`,
        x1: "0",
        y1: "0",
        x2: "0",
        y2: "1"
      }, [
        createElementVNode("stop", {
          offset: "0%",
          "stop-color": `hsl(${$data.hue}deg, 100%, 50%)`,
          "stop-opacity": "1"
        }, null, 8 /* PROPS */, _hoisted_7),
        createElementVNode("stop", {
          offset: "100%",
          "stop-color": `hsl(${$data.hue}deg, 100%, 50%)`,
          "stop-opacity": "0"
        }, null, 8 /* PROPS */, _hoisted_8)
      ], 8 /* PROPS */, _hoisted_6),
      createElementVNode("clipPath", {
        id: `cp-triangle-clip-${$data.id}`
      }, [
        createElementVNode("path", { d: $options.haloPath }, null, 8 /* PROPS */, _hoisted_10)
      ], 8 /* PROPS */, _hoisted_9)
    ]),
    createElementVNode("g", _hoisted_11, [
      (openBlock(), createElementBlock("foreignObject", {
        x: 0,
        y: 0,
        width: $props.size,
        height: $props.size,
        "clip-path": `url(#cp-triangle-clip-${$data.id})`
      }, [
        createElementVNode("div", {
          class: "colorpicker-triangle-hue",
          onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickHue && $options.clickHue(...args))),
          onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
          onTouchstart: _cache[2] || (_cache[2] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
        }, null, 32 /* HYDRATE_EVENTS */)
      ], 8 /* PROPS */, _hoisted_12)),
      createElementVNode("g", {
        style: normalizeStyle(`transform: rotate(${$data.hue}deg)`)
      }, [
        (openBlock(), createElementBlock("foreignObject", {
          x: $props.size / 2 - 4,
          y: 0,
          width: "8",
          height: $props.thickness + 4
        }, [
          createElementVNode("div", {
            ref: "hueCursor",
            class: "hue-range-thumb",
            style: normalizeStyle(`background-color: hsl(${$data.hue}deg, 100%, 50%)`),
            role: "slider",
            tabindex: "0",
            "aria-label": "Hue",
            "aria-valuemin": "0",
            "aria-valuenow": $data.hue,
            "aria-valuemax": "360",
            onClick: _cache[3] || (_cache[3] = (...args) => ($options.clickHue && $options.clickHue(...args))),
            onKeydown: _cache[4] || (_cache[4] = (...args) => ($options.hueKeyPress && $options.hueKeyPress(...args))),
            onMousedown: _cache[5] || (_cache[5] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
            onTouchstart: _cache[6] || (_cache[6] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
          }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_14)
        ], 8 /* PROPS */, _hoisted_13))
      ], 4 /* STYLE */)
    ]),
    createElementVNode("g", {
      class: "colorpicker-triangle-slider-sl",
      style: normalizeStyle(`transform: rotate(${$data.hue}deg) translate(50%, 50%)`),
      role: "graphics-datagroup",
      "aria-datascales": "lightness, saturation"
    }, [
      createElementVNode("path", {
        d: $options.trianglePath,
        fill: `url(#cp-triangle-gradient-ligthness-${$data.id})`
      }, null, 8 /* PROPS */, _hoisted_15),
      createElementVNode("path", {
        d: $options.trianglePath,
        fill: `url(#cp-triangle-gradient-saturation-${$data.id})`,
        style: {"mix-blend-mode":"overlay"},
        onClick: _cache[7] || (_cache[7] = (...args) => ($options.clickSL && $options.clickSL(...args))),
        onMousedown: _cache[8] || (_cache[8] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
        onTouchstart: _cache[9] || (_cache[9] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
      }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_16),
      (openBlock(), createElementBlock("foreignObject", {
        x: (($options.internalRadius - 3) * $data.cos30) * (-$data.lightness + 0.5) * 2 - 6,
        y: -$options.internalRadius + (1 - $data.saturation) * ($options.internalRadius - 3) * 1.5 - 3,
        width: "12",
        height: "12"
      }, [
        createElementVNode("div", {
          ref: "slCursor",
          class: "sl-range-thumb",
          style: normalizeStyle({
                        backgroundColor: `hsl(${$data.hue}deg, ${$data.saturation * 100}%, ${$data.lightness * 100}%)`
                    }),
          tabindex: "0",
          "aria-datavalues": `${$data.saturation * 100}%, ${$data.lightness * 100}%`,
          onClick: _cache[10] || (_cache[10] = (...args) => ($options.clickSL && $options.clickSL(...args))),
          onKeydown: _cache[11] || (_cache[11] = (...args) => ($options.slKeyPress && $options.slKeyPress(...args))),
          onMousedown: _cache[12] || (_cache[12] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
          onTouchstart: _cache[13] || (_cache[13] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
        }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_18)
      ], 8 /* PROPS */, _hoisted_17))
    ], 4 /* STYLE */)
  ], 8 /* PROPS */, _hoisted_1$3))
}

script$3.render = render$3;
script$3.__file = "src/components/colorpicker/ColorpickerHSLRepresentationTriangle.vue";

const precision = (strs, ...values) => {
    const tmp = [];
    strs.forEach((str, i) => {
        tmp.push(str);

        if (values[i]) {
            tmp.push(
                Number.isNaN(values[i] / 1)
                    ? values[i]
                    : Math.round(values * 10) / 10
            );
        }
    });

    return tmp.join('')
};

var script$2 = {
    name: 'BColorpickerHSLRepresentationSquare',
    props: {
        value: {
            type: Object,
            required: true,
            validator(value) {
                return typeof value.hue === 'number' &&
                    typeof value.saturation === 'number' &&
                    typeof value.lightness === 'number'
            }
        },
        size: {
            type: Number,
            default: 200
        },
        thickness: {
            type: Number,
            default: 20
        }
    },
    emits: ['input'],
    data() {
        return {
            hue: this.value.hue,
            saturation: this.value.saturation,
            lightness: this.value.lightness,
            captureMouse: false,
            captureType: 'hue',
            clientOffset: {
                cx: -1,
                cy: -1,
                width: 0,
                height: 0
            },
            debounce: 0
        }
    },
    computed: {
        hueThumbStyle() {
            const { hue, size, thickness } = this;
            const side = size - thickness;
            const offset = size / 2;
            const angle = ((hue + 720 + 90) % 360) / 180 * Math.PI;
            const ciq = 1 / Math.cos(Math.PI / 4);
            const { x, y } = {
                x: -Math.min(1, Math.max(-1, ciq * Math.cos(angle))) / 2 * side + offset,
                y: -Math.min(1, Math.max(-1, ciq * Math.sin(angle))) / 2 * side + offset
            };
            return {
                background: `hsl(${hue}deg, 100%, 50%)`,
                left: precision`${x}px`,
                top: precision`${y}px`,
                width: precision`${thickness - 2}px`
            }
        },
        slThumbStyle() {
            let { hue, saturation, lightness } = this;
            saturation = Math.max(0, Math.min(1, saturation));
            lightness = Math.max(0, Math.min(1, lightness));
            return {
                background: `hsl(${hue}deg, ${saturation * 100}%, ${lightness * 100}%)`,
                left: `${saturation * 100}%`,
                top: `${(1 - lightness) * 100}%`
            }
        },
        SLBackground() {
            const { hue } = this;
            return `linear-gradient(90deg, hsl(${hue}deg, 0%, 50%), hsl(${hue}deg, 100%, 50%))`
        }
    },
    watch: {
        captureMouse(newValue, oldValue) {
            if (oldValue === false && newValue !== false) {
                const rect = this.$el.getBoundingClientRect();
                // Caching offset
                this.clientOffset.cx = rect.x + rect.width / 2;
                this.clientOffset.cy = rect.y + rect.height / 2;
                this.clientOffset.width = rect.width;
                this.clientOffset.height = rect.height;
            }
        },
        value: {
            deep: true,
            handler(newColor) {
                const { hue, saturation, lightness } = newColor;

                window.clearTimeout(this.debounce);
                this.debounce = window.setTimeout(() => {
                    this.hue = hue;
                    this.saturation = saturation;
                    this.lightness = lightness;
                }, 200);
            }
        }
    },
    methods: {
        increaseHue(value = 1) {
            this.hue = (this.hue + value) % 360;
        },
        decreaseHue(value = 1) {
            this.hue = (360 + this.hue - value) % 360;
        },
        increaseSaturation(value = 0.01) {
            this.saturation = Math.min(1, Math.max(0, this.saturation + value));
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness
                )
            );
        },
        decreaseSaturation(value = 0.01) {
            this.saturation = Math.min(1, Math.max(0, this.saturation - value));
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness
                )
            );
        },
        increaseLightness(value = 0.01) {
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness + value
                )
            );
        },
        decreaseLightness(value = 0.01) {
            this.lightness = Math.min(
                0.5 + (1 - this.saturation) * 0.5,
                Math.max(
                    0.5 - (1 - this.saturation) * 0.5,
                    this.lightness - value
                )
            );
        },
        hueKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                case 'ArrowUp':
                    this.increaseHue();
                    handled = true;
                    break
                case 'ArrowLeft':
                case 'ArrowDown':
                    this.decreaseHue();
                    handled = true;
                    break
                case 'Home':
                    this.increaseHue(360 - this.hue);
                    handled = true;
                    break
                case 'End':
                    this.decreaseHue(this.hue);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseHue(60 - this.hue % 60);
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseHue(60 + this.hue % 60);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitColor();
            }
        },
        slKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                    this.increaseSaturation();
                    handled = true;
                    break
                case 'ArrowUp':
                    this.increaseLightness();
                    handled = true;
                    break
                case 'ArrowLeft':
                    this.decreaseSaturation();
                    handled = true;
                    break
                case 'ArrowDown':
                    this.decreaseLightness();
                    handled = true;
                    break
                case 'Home':
                    this.increaseLightness(1 - this.lightness);
                    handled = true;
                    break
                case 'End':
                    this.decreaseLightness(this.lightness);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseSaturation(1 - this.saturation);
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseSaturation(this.saturation);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitColor();
            }
        },
        startMouseCapture(event) {
            event.stopPropagation();

            this.captureMouse = true;
            if (event.target.closest('.colorpicker-square-slider-sl') !== null) {
                this.captureType = 'sl';
            } else {
                this.captureType = 'hue';
            }
        },
        stopMouseCapture(event) {
            if (this.captureMouse !== false) {
                event.preventDefault();
                event.stopPropagation();
                this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus();
            }
            this.captureMouse = false;
        },
        clickHue(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.hueCursor.focus();
        },
        clickSL(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.slCursor.focus();
        },
        trackMouse(event) {
            if (this.captureMouse === false) {
                return
            }
            event.preventDefault();
            event.stopPropagation();

            let [mouseX, mouseY] = [0, 0];
            if (typeof event.touches !== 'undefined' && event.touches.length) {
                [mouseX, mouseY] = [event.touches[0].clientX, event.touches[0].clientY];
            } else {
                [mouseX, mouseY] = [event.clientX, event.clientY];
            }
            const angle = Math.atan2(
                mouseY - this.clientOffset.cy,
                mouseX - this.clientOffset.cx
            );

            if (this.captureType === 'sl') {
                const saturation = (mouseX - this.clientOffset.cx) /
                    (this.clientOffset.width - this.thickness * 2) +
                    0.5;
                const lightness = (mouseY - this.clientOffset.cy) /
                    (this.clientOffset.height - this.thickness * 2) +
                    0.5;

                this.saturation = Math.round(Math.min(1, Math.max(0, saturation)) * 1000) / 1000;
                this.lightness = 1 - Math.round(Math.min(1, Math.max(0, lightness)) * 1000) / 1000;
            } else {
                this.hue = Math.round(angle / Math.PI * 180 + 90) % 360;
            }
            this.emitColor();
        },
        emitColor() {
            const { hue, saturation, lightness } = this;
            this.$emit('input', Color$1.fromHSL(hue, saturation, lightness));
            window.clearTimeout(this.debounce);
        }
    },
    mounted() {
        window.addEventListener('mousemove', this.trackMouse);
        window.addEventListener('touchmove', this.trackMouse, { passive: false });
        window.addEventListener('mouseup', this.stopMouseCapture);
        window.addEventListener('touchend', this.stopMouseCapture);
    },
    beforeUnmount() {
        window.removeEventListener('mousemove', this.trackMouse);
        window.removeEventListener('touchmove', this.trackMouse);
        window.removeEventListener('mouseup', this.stopMouseCapture);
        window.removeEventListener('touchend', this.stopMouseCapture);

        clearTimeout(this.debounce);
    }
};

const _hoisted_1$2 = ["aria-datavalues"];

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: "b-colorpicker-square",
    style: normalizeStyle({ width: `${$props.size}px` })
  }, [
    createElementVNode("div", {
      class: "colorpicker-square-slider-hue",
      onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickHue && $options.clickHue(...args))),
      onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
      onTouchstart: _cache[2] || (_cache[2] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
    }, [
      createElementVNode("div", {
        ref: "hueCursor",
        role: "slider",
        class: "hue-range-thumb",
        tabindex: "0",
        "aria-label": "Hue",
        "aria-valuemin": "0",
        "aria-valuemax": "359",
        style: normalizeStyle($options.hueThumbStyle)
      }, null, 4 /* STYLE */)
    ], 32 /* HYDRATE_EVENTS */),
    createElementVNode("div", {
      class: "colorpicker-square-slider-sl",
      style: normalizeStyle({
                background: $options.SLBackground,
                margin: `${$props.thickness}px`
            }),
      "aria-datascales": "lightness, saturation",
      onClick: _cache[7] || (_cache[7] = (...args) => ($options.clickSL && $options.clickSL(...args))),
      onMousedown: _cache[8] || (_cache[8] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
      onTouchstart: _cache[9] || (_cache[9] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
    }, [
      createElementVNode("div", {
        ref: "slCursor",
        role: "slider",
        class: "sl-range-thumb",
        tabindex: "0",
        "aria-datavalues": `${$data.saturation * 100}%, ${$data.lightness * 100}%`,
        style: normalizeStyle($options.slThumbStyle),
        onClick: _cache[3] || (_cache[3] = (...args) => ($options.clickSL && $options.clickSL(...args))),
        onKeydown: _cache[4] || (_cache[4] = (...args) => ($options.slKeyPress && $options.slKeyPress(...args))),
        onMousedown: _cache[5] || (_cache[5] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
        onTouchstart: _cache[6] || (_cache[6] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
      }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_1$2)
    ], 36 /* STYLE, HYDRATE_EVENTS */)
  ], 4 /* STYLE */))
}

script$2.render = render$2;
script$2.__file = "src/components/colorpicker/ColorpickerHSLRepresentationSquare.vue";

var script$1 = {
    name: 'BColorpickerAlphaSlider',
    components: {
        [script$4.name]: script$4
    },
    props: {
        value: {
            type: Number,
            validator: (value) => value >= 0 && value < 256
        },
        color: [String, Object]
    },
    emits: ['input'],
    data() {
        const color = Color$1.parse(this.color);

        color.alpha = 0;
        return {
            startColor: color.toString('hex'),
            endColor: color.toString('hexa'),
            percent: Math.round((1 - this.value / 255) * 100),
            captureMouse: false,
            clientOffset: {
                cx: -1,
                cy: -1,
                width: 0,
                height: 0
            }
        }
    },
    computed: {
        style() {
            return {
                backgroundImage:
                    `linear-gradient(90deg, ${this.startColor} 0%, ${this.endColor} 100%),
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)`,
                backgroundSize: '100% 100%, 1em 1em, 1em 1em',
                backgroundPosition: '0 0, .5em .5em, 0 0'
            }
        }
    },
    watch: {
        value(newValue, oldValue) {
            if (newValue !== oldValue) {
                this.percent = Math.round((1 - newValue / 255) * 100);
            }
        },
        color(newColor) {
            const color = Color$1.parse(newColor);

            color.alpha = 0;
            this.startColor = color.toString('hex');
            this.endColor = color.toString('hexa');
        },
        captureMouse(newValue, oldValue) {
            if (oldValue === false && newValue !== false) {
                const rect = this.$el.getBoundingClientRect();
                // Caching offset
                this.clientOffset.cx = rect.x + rect.width / 2;
                this.clientOffset.cy = rect.y + rect.height / 2;
                this.clientOffset.width = rect.width;
                this.clientOffset.height = rect.height;
            }
        }
    },
    methods: {
        increaseAlpha(value = 1) {
            this.percent = Math.max(0, Math.min(100, this.percent + value));
        },
        decreaseAlpha(value = 0.01) {
            this.increaseAlpha(-value);
        },
        alphaKeyPress(event) {
            let handled = false;
            switch (event.key) {
                case 'ArrowRight':
                case 'ArrowUp':
                    this.increaseAlpha();
                    handled = true;
                    break
                case 'ArrowLeft':
                case 'ArrowDown':
                    this.decreaseAlpha();
                    handled = true;
                    break
                case 'Home':
                    this.decreaseAlpha(this.percent);
                    handled = true;
                    break
                case 'End':
                    this.increaseAlpha(100 - this.percent);
                    handled = true;
                    break
                case 'PageUp':
                    this.increaseAlpha(10 - (this.percent % 10));
                    handled = true;
                    break
                case 'PageDown':
                    this.decreaseAlpha(this.percent % 10);
                    handled = true;
                    break
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
                this.emitAlpha();
            }
        },
        clickAlpha(event) {
            this.startMouseCapture(event);
            this.trackMouse(event);
            this.stopMouseCapture(event);
            this.$refs.alphaCursor.focus();
        },
        startMouseCapture(event) {
            event.stopPropagation();

            this.captureMouse = true;
        },
        trackMouse(event) {
            if (this.captureMouse === false) {
                return
            }
            event.preventDefault();
            event.stopPropagation();

            let [mouseX] = [0, 0];
            if (typeof event.touches !== 'undefined' && event.touches.length) {
                [mouseX] = [event.touches[0].clientX];
            } else {
                [mouseX] = [event.clientX];
            }

            const ratio = 0.5 + (this.clientOffset.cx - mouseX) / this.clientOffset.width;
            this.percent = Math.round(100 - Math.max(0, Math.min(1, ratio)) * 100);
            this.emitAlpha();
        },
        stopMouseCapture(event) {
            if (this.captureMouse !== false) {
                event.preventDefault();
                event.stopPropagation();
                this.$refs.alphaCursor.focus();
            }
            this.captureMouse = false;
        },
        emitAlpha() {
            this.$emit('input', (1 - this.percent / 100) * 255);
        }
    },
    mounted() {
        window.addEventListener('mousemove', this.trackMouse);
        window.addEventListener('touchmove', this.trackMouse, { passive: false });
        window.addEventListener('mouseup', this.stopMouseCapture);
        window.addEventListener('touchend', this.stopMouseCapture);
    },
    beforeUnmount() {
        window.removeEventListener('mousemove', this.trackMouse);
        window.removeEventListener('touchmove', this.trackMouse);
        window.removeEventListener('mouseup', this.stopMouseCapture);
        window.removeEventListener('touchend', this.stopMouseCapture);
    }
};

const _hoisted_1$1 = ["aria-valuenow"];

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_tooltip = resolveComponent("b-tooltip");

  return (openBlock(), createElementBlock("div", {
    class: "b-colorpicker-alpha-slider",
    style: normalizeStyle($options.style),
    onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickAlpha && $options.clickAlpha(...args))),
    onKeydown: _cache[1] || (_cache[1] = (...args) => ($options.alphaKeyPress && $options.alphaKeyPress(...args))),
    onMousedown: _cache[2] || (_cache[2] = (...args) => ($options.startMouseCapture && $options.startMouseCapture(...args))),
    onTouchstart: _cache[3] || (_cache[3] = withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
  }, [
    createElementVNode("div", {
      ref: "alphaCursor",
      role: "slider",
      class: "alpha-range-thumb",
      tabindex: "0",
      "aria-label": "Tranparency",
      "aria-valuemin": "0",
      "aria-valuenow": $data.percent,
      "aria-valuemax": "100",
      style: normalizeStyle({ left: `${$data.percent}%` })
    }, [
      createVNode(_component_b_tooltip, {
        label: `${$data.percent}%`,
        always: $data.captureMouse
      }, {
        default: withCtx(() => [
          createTextVNode("   ")
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["label", "always"])
    ], 12 /* STYLE, PROPS */, _hoisted_1$1)
  ], 36 /* STYLE, HYDRATE_EVENTS */))
}

script$1.render = render$1;
script$1.__file = "src/components/colorpicker/ColorpickerAlphaSlider.vue";

const defaultColorFormatter = (color, vm) => {
    if (color.alpha < 1) {
        return color.toString('hexa')
    } else {
        return color.toString('hex')
    }
};

const defaultColorParser = (color, vm) => {
    return Color$1.parse(color)
};

var script = {
    name: 'BColorpicker',
    components: {
        [script$3.name]: script$3,
        [script$2.name]: script$2,
        [script$1.name]: script$1,
        [script$5.name]: script$5,
        [script$6.name]: script$6,
        [script$7.name]: script$7,
        [script$8.name]: script$8,
        [script$9.name]: script$9,
        [script$a.name]: script$a
    },
    mixins: [FormElementMixin],
    inheritAttrs: false,
    provide() {
        return {
            $colorpicker: this
        }
    },
    props: {
        modelValue: {
            type: [String, Object],
            validator(value) {
                return typeof value === 'string' ||
                    (
                        typeof value === 'object' &&
                        typeof value.red === 'number' &&
                        typeof value.green === 'number' &&
                        typeof value.blue === 'number'
                    )
            }
        },
        representation: {
            type: String,
            default: 'triangle',
            value(value) {
                return ['triangle', 'square'].some((r) => r === value)
            }
        },
        inline: Boolean,
        disabled: Boolean,
        horizontalColorPicker: {
            type: Boolean,
            default: false
        },
        colorFormatter: {
            type: Function,
            default: (color, vm) => {
                if (typeof config.defaultColorFormatter === 'function') {
                    return config.defaultColorFormatter(color)
                } else {
                    return defaultColorFormatter(color)
                }
            }
        },
        colorParser: {
            type: Function,
            default: (color, vm) => {
                if (typeof config.defaultColorParser === 'function') {
                    return config.defaultColorParser(color)
                } else {
                    return defaultColorParser(color)
                }
            }
        },
        alpha: {
            type: Boolean,
            default: false
        },
        expanded: Boolean,
        position: String,
        mobileModal: {
            type: Boolean,
            default: () => config.defaultDatepickerMobileModal
        },
        focusable: {
            type: Boolean,
            default: true
        },
        trapFocus: {
            type: Boolean,
            default: () => config.defaultTrapFocus
        },
        appendToBody: Boolean
    },
    emits: ['active-change', 'update:modelValue'],
    data() {
        return {
            color: this.parseColor(this.modelValue)
        }
    },
    computed: {
        computedValue: {
            set(value) {
                this.color = this.parseColor(value);
            },
            get() {
                return this.color
            }
        },
        background() {
            if (this.alpha) {
                return `linear-gradient(
                    45deg,
                    ${this.computedValue.toString('hex')} 50%,
                    ${this.computedValue.toString('hexa')} 50%
                )`
            } else {
                const hex = this.computedValue.toString('hex');
                return `linear-gradient(
                    45deg,
                    ${hex} 50%,
                    ${hex} 50%
                )`
            }
        },
        triggerStyle() {
            const { red, green, blue } = this.computedValue;
            const light = (red * 0.299 + green * 0.587 + blue * 0.114) > 186;

            return {
                backgroundColor: '#ffffff',
                backgroundImage: `
                    ${this.background},
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)
                `,
                backgroundSize: '100% 100%, 16px 16px, 16px 16px',
                backgroundPosition: '0 0, 8px 8px, 0 0',
                color: light ? '#000000' : '#FFFFFF',
                textShadow: `0 0 2px ${light ? '#FFFFFFAA' : '#000000AA'}`
            }
        },

        isMobile() {
            return this.mobileNative && isMobile.any()
        },

        ariaRole() {
            if (!this.inline) {
                return 'dialog'
            } else {
                return undefined
            }
        }
    },
    watch: {
        modelValue(value) {
            this.computedValue = new Color$1(value);
        }
    },
    methods: {
        parseColor(color) {
            try {
                return this.colorParser(color)
            } catch (e) {
                return new Color$1()
            }
        },
        updateColor(value) {
            value.alpha = this.computedValue.alpha;
            this.computedValue = value;
            this.$emit('update:modelValue', value);
        },
        updateAlpha(alpha) {
            this.computedValue.alpha = alpha;
            this.$emit('update:modelValue', this.computedValue);
        },
        updateRGB() {
            this.$emit('update:modelValue', this.computedValue);
        },
        /*
         * Format color into string
         */
        formatValue(value) {
            return value ? this.colorFormatter(value, this) : null
        },

        /*
         * Toggle datepicker
         */
        togglePicker(active) {
            if (this.$refs.dropdown) {
                const isActive = typeof active === 'boolean'
                    ? active
                    : !this.$refs.dropdown.isActive;
                if (isActive) {
                    this.$refs.dropdown.isActive = isActive;
                } else if (this.closeOnClick) {
                    this.$refs.dropdown.isActive = isActive;
                }
            }
        },

        /*
         * Call default onFocus method and show datepicker
         */
        handleOnFocus(event) {
            this.onFocus(event);
            if (this.openOnFocus) {
                this.togglePicker(true);
            }
        },

        /*
         * Toggle dropdown
         */
        toggle() {
            if (this.mobileNative && this.isMobile) {
                const input = this.$refs.input.$refs.input;
                input.focus();
                input.click();
                return
            }
            this.$refs.dropdown.toggle();
        },

        /*
         * Avoid dropdown toggle when is already visible
         */
        onInputClick(event) {
            if (this.$refs.dropdown.isActive) {
                event.stopPropagation();
            }
        },

        /**
         * Keypress event that is bound to the document.
         */
        keyPress({ key }) {
            if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
                this.togglePicker(false);
            }
        },

        /**
         * Emit 'blur' event on dropdown is not active (closed)
         */
        onActiveChange(value) {
            if (!value) {
                this.onBlur();
            }
            /*
             * Emit 'active-change' when on dropdown active state change
             */
            this.$emit('active-change', value);
        }
    }
};

const _hoisted_1 = { class: "color-name" };
const _hoisted_2 = { class: "colorpicker-header" };
const _hoisted_3 = { class: "colorpicker-content" };
const _hoisted_4 = { class: "colorpicker-footer" };

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_b_button = resolveComponent("b-button");
  const _component_b_colorpicker_h_s_l_representation_square = resolveComponent("b-colorpicker-h-s-l-representation-square");
  const _component_b_colorpicker_h_s_l_representation_triangle = resolveComponent("b-colorpicker-h-s-l-representation-triangle");
  const _component_b_colorpicker_alpha_slider = resolveComponent("b-colorpicker-alpha-slider");
  const _component_b_input = resolveComponent("b-input");
  const _component_b_field = resolveComponent("b-field");
  const _component_b_dropdown_item = resolveComponent("b-dropdown-item");
  const _component_b_dropdown = resolveComponent("b-dropdown");

  return (openBlock(), createElementBlock("div", {
    class: normalizeClass(["colorpicker control", [_ctx.size, {'is-expanded': $props.expanded}]])
  }, [
    (!$options.isMobile || $props.inline)
      ? (openBlock(), createBlock(_component_b_dropdown, {
          key: 0,
          ref: "dropdown",
          position: $props.position,
          expanded: $props.expanded,
          disabled: $props.disabled,
          inline: $props.inline,
          "mobile-modal": $props.mobileModal,
          "trap-focus": $props.trapFocus,
          "aria-role": $options.ariaRole,
          "append-to-body": $props.appendToBody,
          "append-to-body-copy-parent": "",
          onActiveChange: $options.onActiveChange
        }, createSlots({
          default: withCtx(() => [
            createVNode(_component_b_dropdown_item, {
              disabled: $props.disabled,
              focusable: $props.focusable,
              custom: "",
              class: normalizeClass({'dropdown-horizontal-colorpicker': $props.horizontalColorPicker})
            }, {
              default: withCtx(() => [
                createElementVNode("div", null, [
                  createElementVNode("header", _hoisted_2, [
                    (_ctx.$slots.header !== undefined && _ctx.$slots.header.length)
                      ? renderSlot(_ctx.$slots, "header", { key: 0 })
                      : createCommentVNode("v-if", true)
                  ]),
                  createElementVNode("div", _hoisted_3, [
                    ($props.representation === 'square')
                      ? (openBlock(), createBlock(_component_b_colorpicker_h_s_l_representation_square, {
                          key: 0,
                          value: $options.computedValue,
                          onInput: $options.updateColor
                        }, null, 8 /* PROPS */, ["value", "onInput"]))
                      : (openBlock(), createBlock(_component_b_colorpicker_h_s_l_representation_triangle, {
                          key: 1,
                          value: $options.computedValue,
                          onInput: $options.updateColor
                        }, null, 8 /* PROPS */, ["value", "onInput"]))
                  ])
                ]),
                createElementVNode("footer", _hoisted_4, [
                  ($props.alpha)
                    ? (openBlock(), createBlock(_component_b_colorpicker_alpha_slider, {
                        key: 0,
                        value: $options.computedValue.alpha,
                        onInput: $options.updateAlpha,
                        color: $options.computedValue
                      }, null, 8 /* PROPS */, ["value", "onInput", "color"]))
                    : createCommentVNode("v-if", true),
                  renderSlot(_ctx.$slots, "footer", { color: $options.computedValue }, () => [
                    createVNode(_component_b_field, {
                      class: "colorpicker-fields",
                      grouped: ""
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_b_field, {
                          horizontal: "",
                          label: "R"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_b_input, {
                              type: "number",
                              modelValue: $options.computedValue.red,
                              "onUpdate:modelValue": [
                                _cache[0] || (_cache[0] = $event => (($options.computedValue.red) = $event)),
                                $options.updateRGB
                              ],
                              modelModifiers: { number: true },
                              size: "is-small",
                              "aria-label": "Red"
                            }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"])
                          ]),
                          _: 1 /* STABLE */
                        }),
                        createVNode(_component_b_field, {
                          horizontal: "",
                          label: "G"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_b_input, {
                              type: "number",
                              modelValue: $options.computedValue.green,
                              "onUpdate:modelValue": [
                                _cache[1] || (_cache[1] = $event => (($options.computedValue.green) = $event)),
                                $options.updateRGB
                              ],
                              modelModifiers: { number: true },
                              size: "is-small",
                              "aria-label": "Green"
                            }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"])
                          ]),
                          _: 1 /* STABLE */
                        }),
                        createVNode(_component_b_field, {
                          horizontal: "",
                          label: "B"
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_b_input, {
                              type: "number",
                              modelValue: $options.computedValue.blue,
                              "onUpdate:modelValue": [
                                _cache[2] || (_cache[2] = $event => (($options.computedValue.blue) = $event)),
                                $options.updateRGB
                              ],
                              modelModifiers: { number: true },
                              size: "is-small",
                              "aria-label": "Blue"
                            }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"])
                          ]),
                          _: 1 /* STABLE */
                        })
                      ]),
                      _: 1 /* STABLE */
                    })
                  ])
                ])
              ]),
              _: 3 /* FORWARDED */
            }, 8 /* PROPS */, ["disabled", "focusable", "class"])
          ]),
          _: 2 /* DYNAMIC */
        }, [
          (!$props.inline)
            ? {
                name: "trigger",
                fn: withCtx(() => [
                  renderSlot(_ctx.$slots, "trigger", {}, () => [
                    createVNode(_component_b_button, {
                      style: normalizeStyle($options.triggerStyle),
                      expanded: $props.expanded,
                      disabled: $props.disabled
                    }, {
                      default: withCtx(() => [
                        createElementVNode("span", _hoisted_1, toDisplayString($props.colorFormatter($options.computedValue)), 1 /* TEXT */)
                      ]),
                      _: 1 /* STABLE */
                    }, 8 /* PROPS */, ["style", "expanded", "disabled"])
                  ])
                ]),
                key: "0"
              }
            : undefined
        ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["position", "expanded", "disabled", "inline", "mobile-modal", "trap-focus", "aria-role", "append-to-body", "onActiveChange"]))
      : createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}

script.render = render;
script.__file = "src/components/colorpicker/Colorpicker.vue";

var Plugin = {
  install: function install(Vue) {
    registerComponent(Vue, script);
  }
};
use(Plugin);

export { Color$1 as C, Plugin as P, script as s };
