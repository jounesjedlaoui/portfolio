/*! Buefy v0.1.3 | MIT License | github.com/buefy/buefy */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Notification = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }

  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }

  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var config = {
    defaultContainerElement: null,
    defaultIconPack: 'mdi',
    defaultIconComponent: null,
    defaultIconPrev: 'chevron-left',
    defaultIconNext: 'chevron-right',
    defaultLocale: undefined,
    defaultDialogConfirmText: null,
    defaultDialogCancelText: null,
    defaultSnackbarDuration: 3500,
    defaultSnackbarPosition: null,
    defaultToastDuration: 2000,
    defaultToastPosition: null,
    defaultNotificationDuration: 2000,
    defaultNotificationPosition: null,
    defaultTooltipType: 'is-primary',
    defaultTooltipDelay: null,
    defaultTooltipCloseDelay: null,
    defaultSidebarDelay: null,
    defaultInputAutocomplete: 'on',
    defaultDateFormatter: null,
    defaultDateParser: null,
    defaultDateCreator: null,
    defaultTimeCreator: null,
    defaultDayNames: null,
    defaultMonthNames: null,
    defaultFirstDayOfWeek: null,
    defaultUnselectableDaysOfWeek: null,
    defaultTimeFormatter: null,
    defaultTimeParser: null,
    defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],
    defaultModalScroll: null,
    defaultDatepickerMobileNative: true,
    defaultTimepickerMobileNative: true,
    defaultTimepickerMobileModal: true,
    defaultNoticeQueue: true,
    defaultInputHasCounter: true,
    /**
     * Whether `class`, `style`, and `id` are applied to the root element in
     * components that are affected by Vue 3 change in fallthgourh beahvior.
     * See: https://github.com/ntohq/buefy-next/issues/16
     */
    defaultCompatFallthrough: true,
    defaultTaginputHasCounter: true,
    defaultUseHtml5Validation: true,
    defaultDropdownMobileModal: true,
    defaultFieldLabelPosition: null,
    defaultDatepickerYearsRange: [-100, 10],
    defaultDatepickerNearbyMonthDays: true,
    defaultDatepickerNearbySelectableMonthDays: false,
    defaultDatepickerShowWeekNumber: false,
    defaultDatepickerWeekNumberClickable: false,
    defaultDatepickerMobileModal: true,
    defaultTrapFocus: true,
    defaultAutoFocus: true,
    defaultButtonRounded: false,
    defaultSwitchRounded: true,
    defaultCarouselInterval: 3500,
    defaultTabsExpanded: false,
    defaultTabsAnimated: true,
    defaultTabsType: null,
    defaultStatusIcon: true,
    defaultProgrammaticPromise: false,
    defaultLinkTags: ['a', 'button', 'input', 'router-link', 'nuxt-link', 'n-link', 'RouterLink', 'NuxtLink', 'NLink'],
    defaultImageWebpFallback: null,
    defaultImageLazy: true,
    defaultImageResponsive: true,
    defaultImageRatio: null,
    defaultImageSrcsetFormatter: null,
    defaultBreadcrumbTag: 'a',
    defaultBreadcrumbAlign: 'is-left',
    defaultBreadcrumbSeparator: '',
    defaultBreadcrumbSize: 'is-medium',
    customIconPacks: null
  };

  const PROGRESS_INJECTION_KEY = Symbol('bprogress');

  var script$3 = {
      name: 'BProgress',
      provide() {
          return {
              [PROGRESS_INJECTION_KEY]: this
          }
      },
      props: {
          type: {
              type: [String, Object],
              default: 'is-darkgrey'
          },
          size: String,
          rounded: {
              type: Boolean,
              default: true
          },
          value: {
              type: Number,
              default: undefined
          },
          max: {
              type: Number,
              default: 100
          },
          showValue: {
              type: Boolean,
              default: false
          },
          format: {
              type: String,
              default: 'raw',
              validator: (value) => {
                  return [
                      'raw',
                      'percent'
                  ].indexOf(value) >= 0
              }
          },
          precision: {
              type: Number,
              default: 2
          },
          keepTrailingZeroes: {
              type: Boolean,
              default: false
          },
          locale: {
              type: [String, Array],
              default: () => {
                  return config.defaultLocale
              }
          }
      },
      computed: {
          isIndeterminate() {
              return this.value === undefined || this.value === null
          },
          newType() {
              return [
                  this.size,
                  this.type,
                  {
                      'is-more-than-half': this.value && this.value > this.max / 2
                  }
              ]
          },
          newValue() {
              return this.calculateValue(this.value)
          },
          isNative() {
              return this.$slots.bar === undefined
          },
          wrapperClasses() {
              return {
                  'is-not-native': !this.isNative,
                  [this.size]: typeof this.size === 'string' && !this.isNative
              }
          }
      },
      watch: {
          /**
           * When value is changed back to undefined, value of native progress get reset to 0.
           * Need to add and remove the value attribute to have the indeterminate or not.
           */
          isIndeterminate(indeterminate) {
              this.$nextTick(() => {
                  if (this.$refs.progress) {
                      if (indeterminate) {
                          this.$refs.progress.removeAttribute('value');
                      } else {
                          this.$refs.progress.setAttribute('value', this.value);
                      }
                  }
              });
          }
      },
      methods: {
          calculateValue(value) {
              if (value === undefined || value === null || isNaN(value)) {
                  return undefined
              }

              const minimumFractionDigits = this.keepTrailingZeroes ? this.precision : 0;
              const maximumFractionDigits = this.precision;
              if (this.format === 'percent') {
                  return new Intl.NumberFormat(
                      this.locale,
                      {
                          style: 'percent',
                          minimumFractionDigits,
                          maximumFractionDigits
                      }
                  ).format(value / this.max)
              }

              return new Intl.NumberFormat(
                  this.locale,
                  {
                      minimumFractionDigits,
                      maximumFractionDigits
                  }
              ).format(value)
          }
      }
  };

  const _hoisted_1$1 = ["max", "value"];
  const _hoisted_2$1 = {
    key: 2,
    class: "progress-value"
  };

  function render$3(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(["progress-wrapper", [$options.wrapperClasses, { 'is-squared': !$props.rounded }]])
    }, [
      ($options.isNative)
        ? (vue.openBlock(), vue.createElementBlock("progress", {
            key: 0,
            ref: "progress",
            class: vue.normalizeClass(["progress", [$options.newType, { 'is-squared': !$props.rounded }]]),
            max: $props.max,
            value: $props.value
          }, vue.toDisplayString($options.newValue), 11 /* TEXT, CLASS, PROPS */, _hoisted_1$1))
        : vue.renderSlot(_ctx.$slots, "bar", { key: 1 }),
      ($options.isNative && $props.showValue)
        ? (vue.openBlock(), vue.createElementBlock("p", _hoisted_2$1, [
            vue.renderSlot(_ctx.$slots, "default", {}, () => [
              vue.createTextVNode(vue.toDisplayString($options.newValue), 1 /* TEXT */)
            ])
          ]))
        : vue.createCommentVNode("v-if", true)
    ], 2 /* CLASS */))
  }

  script$3.render = render$3;
  script$3.__file = "src/components/progress/Progress.vue";

  function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

  /**
   * Merge function to replace Object.assign with deep merging possibility
   */
  var isObject = function isObject(item) {
    return _typeof(item) === 'object' && !Array.isArray(item);
  };
  var mergeFn = function mergeFn(target, source) {
    var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (deep || !Object.assign) {
      var isDeep = function isDeep(prop) {
        return isObject(source[prop]) && target !== null && Object.prototype.hasOwnProperty.call(target, prop) && isObject(target[prop]);
      };
      var replaced = Object.getOwnPropertyNames(source).map(function (prop) {
        return _defineProperty({}, prop, isDeep(prop) ? mergeFn(target[prop], source[prop], deep) : source[prop]);
      }).reduce(function (a, b) {
        return _objectSpread$2(_objectSpread$2({}, a), b);
      }, {});
      return _objectSpread$2(_objectSpread$2({}, target), replaced);
    } else {
      return Object.assign(target, source);
    }
  };
  var merge = mergeFn;
  function removeElement(el) {
    if (typeof el.remove !== 'undefined') {
      el.remove();
    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {
      el.parentNode.removeChild(el);
    }
  }

  // references
  // - https://github.com/vuejs/core/blob/1c525f75a3d17a6356d5f66765623c0ae7c0ebcc/packages/runtime-core/src/apiCreateApp.ts#L361
  // - https://github.com/vuejs/core/blob/1c525f75a3d17a6356d5f66765623c0ae7c0ebcc/packages/runtime-core/src/component.ts#L1036-L1054
  //
  // we cannot access getExposeProxy since it is not exported from `vue`, though,
  // its purpose seems to be one-time initialization of component.exposeProxy,
  // which should have been done by this function call
  function getComponentFromVNode(vnode) {
    if (!vnode) {
      return undefined;
    }
    var component = vnode.component;
    if (!component) {
      return undefined;
    }
    return component.exposed && component.exposeProxy || component.proxy;
  }

  // Copies the context from a given app to another app.
  //
  // This function is necessary to programmatically mount a component; e.g.,
  // Modal.
  // Since Vue 3's app can mount only one component, we have to create a new app
  // to mount another new component.
  // If we create a new app with `createApp` API, no context (e.g., installed
  // components, directives) is available on the new app.
  // This function can copy the context from the host app to the new app.
  //
  // Depends on what Vue internally does: https://github.com/vuejs/core/blob/b775b71c788499ec7ee58bc2cf4cd04ed388e072/packages/runtime-core/src/apiCreateApp.ts#L170-L190
  //
  // This function also should take care of compatiblity with other plugins.
  // We need a generic solution, though, it fixes compatiblity issues of
  // individual plugins for now.
  function copyAppContext(src, dest) {
    // replacing _context won't work because methods of app bypasses app._context
    var srcContext = src._context;
    var destContext = dest._context;
    destContext.config = srcContext.config;
    destContext.mixins = srcContext.mixins;
    destContext.components = srcContext.components;
    destContext.directives = srcContext.directives;
    destContext.provides = srcContext.provides;
    destContext.optionsCache = srcContext.optionsCache;
    destContext.propsCache = srcContext.propsCache;
    destContext.emitsCache = srcContext.emitsCache;
    // vue-i18n support: https://github.com/ntohq/buefy-next/issues/153
    if ('__VUE_I18N_SYMBOL__' in src) {
      dest.__VUE_I18N_SYMBOL__ = src.__VUE_I18N_SYMBOL__;
    }
  }

  var mdiIcons = {
    sizes: {
      "default": 'mdi-24px',
      'is-small': null,
      'is-medium': 'mdi-36px',
      'is-large': 'mdi-48px'
    },
    iconPrefix: 'mdi-'
  };
  var faIcons = function faIcons() {
    var faIconPrefix = config && config.defaultIconComponent ? '' : 'fa-';
    return {
      sizes: {
        "default": null,
        'is-small': null,
        'is-medium': faIconPrefix + 'lg',
        'is-large': faIconPrefix + '2x'
      },
      iconPrefix: faIconPrefix,
      internalIcons: {
        information: 'info-circle',
        alert: 'exclamation-triangle',
        'alert-circle': 'exclamation-circle',
        'chevron-right': 'angle-right',
        'chevron-left': 'angle-left',
        'chevron-down': 'angle-down',
        'eye-off': 'eye-slash',
        'menu-down': 'caret-down',
        'menu-up': 'caret-up',
        'close-circle': 'times-circle'
      }
    };
  };
  var getIcons = function getIcons() {
    var icons = {
      mdi: mdiIcons,
      fa: faIcons(),
      fas: faIcons(),
      far: faIcons(),
      fad: faIcons(),
      fab: faIcons(),
      fal: faIcons(),
      'fa-solid': faIcons(),
      'fa-regular': faIcons(),
      'fa-light': faIcons(),
      'fa-thin': faIcons(),
      'fa-duotone': faIcons(),
      'fa-brands': faIcons()
    };
    if (config && config.customIconPacks) {
      icons = merge(icons, config.customIconPacks, true);
    }
    return icons;
  };
  var getIcons$1 = getIcons;

  var script$2 = {
      name: 'BIcon',
      props: {
          type: [String, Object],
          component: String,
          pack: String,
          icon: String,
          size: String,
          customSize: String,
          customClass: String,
          both: Boolean // This is used internally to show both MDI and FA icon
      },
      computed: {
          iconConfig() {
              const allIcons = getIcons$1();
              return allIcons[this.newPack]
          },
          iconPrefix() {
              if (this.iconConfig && this.iconConfig.iconPrefix) {
                  return this.iconConfig.iconPrefix
              }
              return ''
          },
          /**
          * Internal icon name based on the pack.
          * If pack is 'fa', gets the equivalent FA icon name of the MDI,
          * internal icons are always MDI.
          */
          newIcon() {
              return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`
          },
          newPack() {
              return this.pack || config.defaultIconPack
          },
          newType() {
              if (!this.type) return

              let splitType = [];
              if (typeof this.type === 'string') {
                  splitType = this.type.split('-');
              } else {
                  for (const key in this.type) {
                      if (this.type[key]) {
                          splitType = key.split('-');
                          break
                      }
                  }
              }
              if (splitType.length <= 1) return

              const [, ...type] = splitType;
              return `has-text-${type.join('-')}`
          },
          newCustomSize() {
              return this.customSize || this.customSizeByPack
          },
          customSizeByPack() {
              if (this.iconConfig && this.iconConfig.sizes) {
                  if (this.size && this.iconConfig.sizes[this.size] !== undefined) {
                      return this.iconConfig.sizes[this.size]
                  } else if (this.iconConfig.sizes.default) {
                      return this.iconConfig.sizes.default
                  }
              }
              return null
          },
          useIconComponent() {
              return this.component || config.defaultIconComponent
          }
      },
      methods: {
          /**
          * Equivalent icon name of the MDI.
          */
          getEquivalentIconOf(value) {
              // Only transform the class if the both prop is set to true
              if (!this.both) {
                  return value
              }

              if (this.iconConfig &&
                  this.iconConfig.internalIcons &&
                  this.iconConfig.internalIcons[value]) {
                  return this.iconConfig.internalIcons[value]
              }
              return value
          }
      }
  };

  function render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(["icon", [$options.newType, $props.size]])
    }, [
      (!$options.useIconComponent)
        ? (vue.openBlock(), vue.createElementBlock("i", {
            key: 0,
            class: vue.normalizeClass([$options.newPack, $options.newIcon, $options.newCustomSize, $props.customClass])
          }, null, 2 /* CLASS */))
        : (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent($options.useIconComponent), {
            key: 1,
            icon: [$options.newPack, $options.newIcon],
            size: $options.newCustomSize,
            class: vue.normalizeClass([$props.customClass])
          }, null, 8 /* PROPS */, ["icon", "size", "class"]))
    ], 2 /* CLASS */))
  }

  script$2.render = render$2;
  script$2.__file = "src/components/icon/Icon.vue";

  var MessageMixin = {
    components: _defineProperty({}, script$2.name, script$2),
    props: {
      modelValue: {
        type: Boolean,
        "default": true
      },
      title: String,
      closable: {
        type: Boolean,
        "default": true
      },
      message: String,
      type: String,
      hasIcon: Boolean,
      size: String,
      icon: String,
      iconPack: String,
      iconSize: String,
      autoClose: {
        type: Boolean,
        "default": false
      },
      duration: {
        type: Number,
        "default": 2000
      },
      progressBar: {
        type: Boolean,
        "default": false
      }
    },
    emits: ['click', 'close', 'update:modelValue'],
    data: function data() {
      return {
        isActive: this.modelValue,
        remainingTime: this.duration / 1000,
        // in seconds
        newIconSize: this.iconSize || this.size || 'is-large'
      };
    },
    watch: {
      modelValue: function modelValue(value) {
        this.isActive = value;
      },
      isActive: function isActive(value) {
        if (value) {
          this.setAutoClose();
          this.setDurationProgress();
        } else {
          if (this.timer) {
            clearTimeout(this.timer);
          }
        }
      }
    },
    computed: {
      /**
       * Icon name (MDI) based on type.
       */
      computedIcon: function computedIcon() {
        if (this.icon) {
          return this.icon;
        }
        switch (this.type) {
          case 'is-info':
            return 'information';
          case 'is-success':
            return 'check-circle';
          case 'is-warning':
            return 'alert';
          case 'is-danger':
            return 'alert-circle';
          default:
            return null;
        }
      }
    },
    methods: {
      /**
       * Close the Message and emit events.
       */
      close: function close() {
        this.isActive = false;
        this.resetDurationProgress();
        this.$emit('close');
        this.$emit('update:modelValue', false);
      },
      click: function click() {
        this.$emit('click');
      },
      /**
       * Set timer to auto close message
       */
      setAutoClose: function setAutoClose() {
        var _this = this;
        if (this.autoClose) {
          this.timer = setTimeout(function () {
            if (_this.isActive) {
              _this.close();
            }
          }, this.duration);
        }
      },
      setDurationProgress: function setDurationProgress() {
        var _this2 = this;
        if (this.progressBar || this.autoClose) {
          /**
           * Runs every one second to set the duration passed before
           * the alert will auto close to show it in the progress bar (Remaining Time)
           */
          this.$buefy.globalNoticeInterval = setInterval(function () {
            if (_this2.remainingTime !== 0) {
              _this2.remainingTime -= 1;
            } else {
              _this2.resetDurationProgress();
            }
          }, 1000);
        }
      },
      resetDurationProgress: function resetDurationProgress() {
        var _this3 = this;
        /**
         * Wait until the component get closed and then reset
         **/
        setTimeout(function () {
          _this3.remainingTime = _this3.duration / 1000;
          clearInterval(_this3.$buefy.globalNoticeInterval);
        }, 100);
      }
    },
    mounted: function mounted() {
      this.setAutoClose();
    }
  };

  var script$1 = {
      name: 'BNotification',
      components: {
          // directly registers Progress
          // in case Notification is programmatically opened
          [script$3.name]: script$3
      },
      mixins: [MessageMixin],
      props: {
          position: String,
          ariaCloseLabel: String,
          animation: {
              type: String,
              default: 'fade'
          }
      }
  };

  const _hoisted_1 = ["aria-label"];
  const _hoisted_2 = {
    key: 1,
    class: "media"
  };
  const _hoisted_3 = {
    key: 0,
    class: "media-left"
  };
  const _hoisted_4 = { class: "media-content" };
  const _hoisted_5 = ["innerHTML"];

  function render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_b_icon = vue.resolveComponent("b-icon");
    const _component_b_progress = vue.resolveComponent("b-progress");

    return (vue.openBlock(), vue.createBlock(vue.Transition, {
      name: $props.animation,
      persisted: ""
    }, {
      default: vue.withCtx(() => [
        vue.withDirectives(vue.createElementVNode("article", {
          class: vue.normalizeClass(["notification", [_ctx.type, $props.position]]),
          onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.click && _ctx.click(...args)))
        }, [
          (_ctx.closable)
            ? (vue.openBlock(), vue.createElementBlock("button", {
                key: 0,
                class: "delete",
                type: "button",
                onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.close && _ctx.close(...args))),
                "aria-label": $props.ariaCloseLabel
              }, null, 8 /* PROPS */, _hoisted_1))
            : vue.createCommentVNode("v-if", true),
          (_ctx.$slots.default || _ctx.message)
            ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2, [
                (_ctx.computedIcon && _ctx.hasIcon)
                  ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3, [
                      vue.createVNode(_component_b_icon, {
                        icon: _ctx.computedIcon,
                        pack: _ctx.iconPack,
                        size: _ctx.newIconSize,
                        both: "",
                        "aria-hidden": ""
                      }, null, 8 /* PROPS */, ["icon", "pack", "size"])
                    ]))
                  : vue.createCommentVNode("v-if", true),
                vue.createElementVNode("div", _hoisted_4, [
                  (_ctx.$slots.default)
                    ? vue.renderSlot(_ctx.$slots, "default", { key: 0 })
                    : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                        vue.createCommentVNode(" eslint-disable-next-line vue/no-v-html "),
                        vue.createElementVNode("p", {
                          class: "text",
                          innerHTML: _ctx.message
                        }, null, 8 /* PROPS */, _hoisted_5)
                      ], 64 /* STABLE_FRAGMENT */))
                ])
              ]))
            : vue.createCommentVNode("v-if", true),
          (_ctx.progressBar)
            ? (vue.openBlock(), vue.createBlock(_component_b_progress, {
                key: 2,
                class: "auto-close-progress",
                value: _ctx.remainingTime - 1,
                max: _ctx.duration / 1000 - 1,
                type: _ctx.type,
                rounded: false
              }, null, 8 /* PROPS */, ["value", "max", "type"]))
            : vue.createCommentVNode("v-if", true)
        ], 2 /* CLASS */), [
          [vue.vShow, _ctx.isActive]
        ])
      ]),
      _: 3 /* FORWARDED */
    }, 8 /* PROPS */, ["name"]))
  }

  script$1.render = render$1;
  script$1.__file = "src/components/notification/Notification.vue";

  var NoticeMixin = {
    props: {
      type: {
        type: String,
        "default": 'is-dark'
      },
      message: [String, Array],
      duration: Number,
      queue: {
        type: Boolean,
        "default": undefined
      },
      indefinite: {
        type: Boolean,
        "default": false
      },
      pauseOnHover: {
        type: Boolean,
        "default": false
      },
      position: {
        type: String,
        "default": 'is-top',
        validator: function validator(value) {
          return ['is-top-right', 'is-top', 'is-top-left', 'is-bottom-right', 'is-bottom', 'is-bottom-left'].indexOf(value) > -1;
        }
      },
      container: String
    },
    emits: ['click', 'close'],
    data: function data() {
      return {
        isActive: false,
        isPaused: false,
        parentTop: null,
        parentBottom: null,
        newContainer: this.container || config.defaultContainerElement
      };
    },
    computed: {
      correctParent: function correctParent() {
        switch (this.position) {
          case 'is-top-right':
          case 'is-top':
          case 'is-top-left':
            return this.parentTop;
          case 'is-bottom-right':
          case 'is-bottom':
          case 'is-bottom-left':
            return this.parentBottom;
        }
      },
      transition: function transition() {
        switch (this.position) {
          case 'is-top-right':
          case 'is-top':
          case 'is-top-left':
            return {
              enter: 'fadeInDown',
              leave: 'fadeOut'
            };
          case 'is-bottom-right':
          case 'is-bottom':
          case 'is-bottom-left':
            return {
              enter: 'fadeInUp',
              leave: 'fadeOut'
            };
        }
      }
    },
    methods: {
      pause: function pause() {
        if (this.pauseOnHover && !this.indefinite) {
          this.isPaused = true;
          clearInterval(this.$buefy.globalNoticeInterval);
        }
      },
      removePause: function removePause() {
        if (this.pauseOnHover && !this.indefinite) {
          this.isPaused = false;
          this.close();
        }
      },
      shouldQueue: function shouldQueue() {
        var queue = this.queue !== undefined ? this.queue : config.defaultNoticeQueue;
        if (!queue) return false;
        return this.parentTop.childElementCount > 0 || this.parentBottom.childElementCount > 0;
      },
      click: function click() {
        this.$emit('click');
      },
      close: function close() {
        var _this = this;
        if (!this.isPaused) {
          clearTimeout(this.timer);
          this.isActive = false;
          this.$emit('close');

          // Timeout for the animation complete before destroying
          setTimeout(function () {
            removeElement(_this.$el);
          }, 150);
        }
      },
      timeoutCallback: function timeoutCallback() {
        return this.close();
      },
      showNotice: function showNotice() {
        var _this2 = this;
        if (this.shouldQueue()) this.correctParent.innerHTML = '';
        this.correctParent.insertAdjacentElement('afterbegin', this.$el);
        this.isActive = true;
        if (!this.indefinite) {
          this.timer = setTimeout(function () {
            return _this2.timeoutCallback();
          }, this.newDuration);
        }
      },
      setupContainer: function setupContainer() {
        this.parentTop = document.querySelector((this.newContainer ? this.newContainer : 'body') + '>.notices.is-top');
        this.parentBottom = document.querySelector((this.newContainer ? this.newContainer : 'body') + '>.notices.is-bottom');
        if (this.parentTop && this.parentBottom) return;
        if (!this.parentTop) {
          this.parentTop = document.createElement('div');
          this.parentTop.className = 'notices is-top';
        }
        if (!this.parentBottom) {
          this.parentBottom = document.createElement('div');
          this.parentBottom.className = 'notices is-bottom';
        }
        var container = document.querySelector(this.newContainer) || document.body;
        container.appendChild(this.parentTop);
        container.appendChild(this.parentBottom);
        if (this.newContainer) {
          this.parentTop.classList.add('has-custom-container');
          this.parentBottom.classList.add('has-custom-container');
        }
      }
    },
    beforeMount: function beforeMount() {
      this.setupContainer();
    },
    mounted: function mounted() {
      this.showNotice();
    }
  };

  function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

  // drops props not used by `NoticeMixin` itself
  // - type
  // - message
  // - duration
  var _NoticeMixin$props = NoticeMixin.props,
    queue = _NoticeMixin$props.queue,
    indefinite = _NoticeMixin$props.indefinite,
    pauseOnHover = _NoticeMixin$props.pauseOnHover,
    position = _NoticeMixin$props.position,
    container = _NoticeMixin$props.container;
  var NoticeMixinSubset = _objectSpread$1(_objectSpread$1({}, NoticeMixin), {}, {
    props: {
      queue: queue,
      indefinite: indefinite,
      pauseOnHover: pauseOnHover,
      position: position,
      container: container
    }
  });

  var script = {
      name: 'BNotificationNotice',
      components: {
          [script$1.name]: script$1
      },
      mixins: [NoticeMixinSubset],
      props: {
          duration: Number
      },
      emits: ['close'],
      data() {
          return {
              newDuration: this.duration || config.defaultNotificationDuration
          }
      },
      methods: {
          close() {
              if (!this.isPaused) {
                  clearTimeout(this.timer);
                  this.$refs.notification.isActive = false;
                  this.$emit('close');

                  // Timeout for the animation complete before destroying
                  setTimeout(() => {
                      removeElement(this.$el);
                  }, 150);
              }
          }
      }
  };

  function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_b_notification = vue.resolveComponent("b-notification");

    return (_ctx.$slots.default != null)
      ? (vue.openBlock(), vue.createBlock(_component_b_notification, vue.mergeProps({
          key: 0,
          ref: "notification",
          position: _ctx.position,
          "model-value": _ctx.isActive
        }, _ctx.$attrs, {
          duration: $props.duration,
          onClick: _ctx.click,
          onClose: $options.close,
          onMouseenter: _ctx.pause,
          onMouseleave: _ctx.removePause
        }), {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default")
          ]),
          _: 3 /* FORWARDED */
        }, 16 /* FULL_PROPS */, ["position", "model-value", "duration", "onClick", "onClose", "onMouseenter", "onMouseleave"]))
      : (vue.openBlock(), vue.createBlock(_component_b_notification, vue.mergeProps({
          key: 1,
          ref: "notification",
          position: _ctx.position,
          "model-value": _ctx.isActive
        }, _ctx.$attrs, {
          duration: $props.duration,
          onClick: _ctx.click,
          onClose: $options.close,
          onMouseenter: _ctx.pause,
          onMouseleave: _ctx.removePause
        }), null, 16 /* FULL_PROPS */, ["position", "model-value", "duration", "onClick", "onClose", "onMouseenter", "onMouseleave"]))
  }

  script.render = render;
  script.__file = "src/components/notification/NotificationNotice.vue";

  var use = function use(plugin) {
    if (typeof window !== 'undefined' && window.Vue) {
      window.Vue.use(plugin);
    }
  };

  // use `name` to register a Functional Component which will become unresolvable
  // in production build due to name mangling.
  var registerComponent = function registerComponent(Vue, component, name) {
    Vue.component(name || component.name, component);
  };
  var registerComponentProgrammatic = function registerComponentProgrammatic(Vue, property, component) {
    if (!Vue.config.globalProperties.$buefy) Vue.config.globalProperties.$buefy = {};
    Vue.config.globalProperties.$buefy[property] = component;
  };

  function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  var NotificationProgrammatic = /*#__PURE__*/function () {
    function NotificationProgrammatic(app) {
      _classCallCheck(this, NotificationProgrammatic);
      this.app = app; // may be undefined in the testing environment
    }
    _createClass(NotificationProgrammatic, [{
      key: "open",
      value: function open(params) {
        if (typeof params === 'string') {
          params = {
            message: params
          };
        }
        var defaultParam = {
          position: 'is-top-right'
        };
        if (params.parent) {
          delete params.parent;
        }
        var _onClose;
        if (typeof params.onClose === 'function') {
          _onClose = params.onClose;
          delete params.onClose;
        }
        var slot;
        if (Array.isArray(params.message)) {
          slot = params.message;
          delete params.message;
        }
        var propsData = merge(defaultParam, params);
        var container = document.createElement('div');
        // Vue 3 requires a new app to mount another component
        var vueInstance = vue.createApp({
          data: function data() {
            return {
              noticeVNode: null
            };
          },
          methods: {
            close: function close() {
              var notice = getComponentFromVNode(this.noticeVNode);
              if (notice) {
                notice.close();
              }
            }
          },
          render: function render() {
            this.noticeVNode = vue.h(script, _objectSpread(_objectSpread({}, propsData), {}, {
              onClose: function onClose() {
                if (_onClose != null) {
                  _onClose();
                }
                // waits for a while in favor of animation
                setTimeout(function () {
                  vueInstance.unmount();
                }, 150);
              }
            }), slot != null ? {
              "default": function _default() {
                return slot;
              }
            } : undefined);
            return this.noticeVNode;
          }
        });
        if (this.app) {
          copyAppContext(this.app, vueInstance);
        } else {
          // workaround for an error that
          // $buefy.globalNoticeInterval is not defined
          vueInstance.use({
            install: function install(Vue) {
              Vue.config.globalProperties.$buefy = {
                globalNoticeInterval: null
              };
            }
          });
        }
        return vueInstance.mount(container);
      }
    }]);
    return NotificationProgrammatic;
  }();
  var Plugin = {
    install: function install(Vue) {
      registerComponent(Vue, script$1);
      registerComponentProgrammatic(Vue, 'notification', new NotificationProgrammatic(Vue));
    }
  };
  use(Plugin);

  exports.BNotification = script$1;
  exports.NotificationProgrammatic = NotificationProgrammatic;
  exports.default = Plugin;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
