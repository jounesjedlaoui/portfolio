/*! Buefy v0.1.3 | MIT License | github.com/buefy/buefy */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
    typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Colorpicker = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

    var config = {
      defaultContainerElement: null,
      defaultIconPack: 'mdi',
      defaultIconComponent: null,
      defaultIconPrev: 'chevron-left',
      defaultIconNext: 'chevron-right',
      defaultLocale: undefined,
      defaultDialogConfirmText: null,
      defaultDialogCancelText: null,
      defaultSnackbarDuration: 3500,
      defaultSnackbarPosition: null,
      defaultToastDuration: 2000,
      defaultToastPosition: null,
      defaultNotificationDuration: 2000,
      defaultNotificationPosition: null,
      defaultTooltipType: 'is-primary',
      defaultTooltipDelay: null,
      defaultTooltipCloseDelay: null,
      defaultSidebarDelay: null,
      defaultInputAutocomplete: 'on',
      defaultDateFormatter: null,
      defaultDateParser: null,
      defaultDateCreator: null,
      defaultTimeCreator: null,
      defaultDayNames: null,
      defaultMonthNames: null,
      defaultFirstDayOfWeek: null,
      defaultUnselectableDaysOfWeek: null,
      defaultTimeFormatter: null,
      defaultTimeParser: null,
      defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],
      defaultModalScroll: null,
      defaultDatepickerMobileNative: true,
      defaultTimepickerMobileNative: true,
      defaultTimepickerMobileModal: true,
      defaultNoticeQueue: true,
      defaultInputHasCounter: true,
      /**
       * Whether `class`, `style`, and `id` are applied to the root element in
       * components that are affected by Vue 3 change in fallthgourh beahvior.
       * See: https://github.com/ntohq/buefy-next/issues/16
       */
      defaultCompatFallthrough: true,
      defaultTaginputHasCounter: true,
      defaultUseHtml5Validation: true,
      defaultDropdownMobileModal: true,
      defaultFieldLabelPosition: null,
      defaultDatepickerYearsRange: [-100, 10],
      defaultDatepickerNearbyMonthDays: true,
      defaultDatepickerNearbySelectableMonthDays: false,
      defaultDatepickerShowWeekNumber: false,
      defaultDatepickerWeekNumberClickable: false,
      defaultDatepickerMobileModal: true,
      defaultTrapFocus: true,
      defaultAutoFocus: true,
      defaultButtonRounded: false,
      defaultSwitchRounded: true,
      defaultCarouselInterval: 3500,
      defaultTabsExpanded: false,
      defaultTabsAnimated: true,
      defaultTabsType: null,
      defaultStatusIcon: true,
      defaultProgrammaticPromise: false,
      defaultLinkTags: ['a', 'button', 'input', 'router-link', 'nuxt-link', 'n-link', 'RouterLink', 'NuxtLink', 'NLink'],
      defaultImageWebpFallback: null,
      defaultImageLazy: true,
      defaultImageResponsive: true,
      defaultImageRatio: null,
      defaultImageSrcsetFormatter: null,
      defaultBreadcrumbTag: 'a',
      defaultBreadcrumbAlign: 'is-left',
      defaultBreadcrumbSeparator: '',
      defaultBreadcrumbSize: 'is-medium',
      customIconPacks: null
    };

    var FormElementMixin = {
      props: {
        size: String,
        expanded: Boolean,
        loading: Boolean,
        rounded: Boolean,
        icon: String,
        iconPack: String,
        // Native options to use in HTML5 validation
        autocomplete: String,
        maxlength: [Number, String],
        useHtml5Validation: {
          type: Boolean,
          "default": function _default() {
            return config.defaultUseHtml5Validation;
          }
        },
        validationMessage: String,
        locale: {
          type: [String, Array],
          "default": function _default() {
            return config.defaultLocale;
          }
        },
        statusIcon: {
          type: Boolean,
          "default": function _default() {
            return config.defaultStatusIcon;
          }
        }
      },
      emits: ['blur', 'focus'],
      data: function data() {
        return {
          isValid: true,
          isFocused: false,
          newIconPack: this.iconPack || config.defaultIconPack
        };
      },
      computed: {
        /**
         * Find parent Field, max 3 levels deep.
         */
        parentField: function parentField() {
          var parent = this.$parent;
          for (var i = 0; i < 3; i++) {
            if (parent && !parent.$data._isField) {
              parent = parent.$parent;
            }
          }
          return parent;
        },
        /**
         * Get the type prop from parent if it's a Field.
         */
        statusType: function statusType() {
          var _ref = this.parentField || {},
            newType = _ref.newType;
          if (!newType) return;
          if (typeof newType === 'string') {
            return newType;
          } else {
            for (var key in newType) {
              if (newType[key]) {
                return key;
              }
            }
          }
        },
        /**
         * Get the message prop from parent if it's a Field.
         */
        statusMessage: function statusMessage() {
          if (!this.parentField) return;
          return this.parentField.newMessage || this.parentField.$slots.message;
        },
        /**
         * Fix icon size for inputs, large was too big
         */
        iconSize: function iconSize() {
          switch (this.size) {
            case 'is-small':
              return this.size;
            case 'is-medium':
              return;
            case 'is-large':
              return this.newIconPack === 'mdi' ? 'is-medium' : '';
          }
        }
      },
      methods: {
        /**
         * Focus method that work dynamically depending on the component.
         */
        focus: function focus() {
          var el = this.getElement();
          if (el === undefined) return;
          this.$nextTick(function () {
            if (el) el.focus();
          });
        },
        onBlur: function onBlur($event) {
          this.isFocused = false;
          this.$emit('blur', $event);
          this.checkHtml5Validity();
        },
        onFocus: function onFocus($event) {
          this.isFocused = true;
          this.$emit('focus', $event);
        },
        getElement: function getElement() {
          var el = this.$refs[this.$data._elementRef];
          while (el != null && '$refs' in el) {
            el = el.$refs[el.$data._elementRef];
          }
          return el;
        },
        setInvalid: function setInvalid() {
          var type = 'is-danger';
          var message = this.validationMessage || this.getElement().validationMessage;
          this.setValidity(type, message);
        },
        setValidity: function setValidity(type, message) {
          var _this = this;
          this.$nextTick(function () {
            if (_this.parentField) {
              // Set type only if not defined
              if (!_this.parentField.type) {
                _this.parentField.newType = type;
              }
              // Set message only if not defined
              if (!_this.parentField.message) {
                _this.parentField.newMessage = message;
              }
            }
          });
        },
        /**
         * Check HTML5 validation, set isValid property.
         * If validation fail, send 'is-danger' type,
         * and error message to parent if it's a Field.
         */
        checkHtml5Validity: function checkHtml5Validity() {
          if (!this.useHtml5Validation) return;
          var el = this.getElement();
          if (el == null) return;
          if (!el.checkValidity()) {
            this.setInvalid();
            this.isValid = false;
          } else {
            this.setValidity(null, null);
            this.isValid = true;
          }
          return this.isValid;
        }
      }
    };

    function _typeof(o) {
      "@babel/helpers - typeof";

      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
        return typeof o;
      } : function (o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
      }, _typeof(o);
    }

    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }

    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }

    function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
    function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

    /**
     * Merge function to replace Object.assign with deep merging possibility
     */
    var isObject = function isObject(item) {
      return _typeof(item) === 'object' && !Array.isArray(item);
    };
    var mergeFn = function mergeFn(target, source) {
      var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (deep || !Object.assign) {
        var isDeep = function isDeep(prop) {
          return isObject(source[prop]) && target !== null && Object.prototype.hasOwnProperty.call(target, prop) && isObject(target[prop]);
        };
        var replaced = Object.getOwnPropertyNames(source).map(function (prop) {
          return _defineProperty({}, prop, isDeep(prop) ? mergeFn(target[prop], source[prop], deep) : source[prop]);
        }).reduce(function (a, b) {
          return _objectSpread(_objectSpread({}, a), b);
        }, {});
        return _objectSpread(_objectSpread({}, target), replaced);
      } else {
        return Object.assign(target, source);
      }
    };
    var merge = mergeFn;

    /**
     * Mobile detection
     * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript
     */
    var isMobile = {
      Android: function Android() {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/Android/i);
      },
      BlackBerry: function BlackBerry() {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/BlackBerry/i);
      },
      iOS: function iOS() {
        return typeof window !== 'undefined' && (window.navigator.userAgent.match(/iPhone|iPad|iPod/i) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);
      },
      Opera: function Opera() {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/Opera Mini/i);
      },
      Windows: function Windows() {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/IEMobile/i);
      },
      any: function any() {
        return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
      }
    };
    function removeElement(el) {
      if (typeof el.remove !== 'undefined') {
        el.remove();
      } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {
        el.parentNode.removeChild(el);
      }
    }
    function createAbsoluteElement(el) {
      var root = document.createElement('div');
      root.style.position = 'absolute';
      root.style.left = '0px';
      root.style.top = '0px';
      root.style.width = '100%';
      var wrapper = document.createElement('div');
      root.appendChild(wrapper);
      wrapper.appendChild(el);
      document.body.appendChild(root);
      return root;
    }
    function toCssWidth(width) {
      return width === undefined ? null : isNaN(width) ? width : width + 'px';
    }
    function isCustomElement(vm) {
      return 'shadowRoot' in vm.$root.$options;
    }

    // TODO: replacement of vnode.tag test
    function isTag(vnode) {
      return vnode.type !== vue.Comment && vnode.type !== vue.Text && vnode.type !== vue.Static;
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e,
          n,
          i,
          u,
          a = [],
          f = !0,
          o = !1;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = !1;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
          o = !0, n = r;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _isNativeFunction(fn) {
      try {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      } catch (e) {
        return typeof fn === "function";
      }
    }

    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct$1()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;
      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);
          _cache.set(Class, Wrapper);
        }
        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };
      return _wrapNativeSuper(Class);
    }

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
    var colorChannels = ['red', 'green', 'blue', 'alpha'];
    var colorsNammed = {
      transparent: '#00000000',
      black: '#000000',
      silver: '#c0c0c0',
      gray: '#808080',
      white: '#ffffff',
      maroon: '#800000',
      red: '#ff0000',
      purple: '#800080',
      fuchsia: '#ff00ff',
      green: '#008000',
      lime: '#00ff00',
      olive: '#808000',
      yellow: '#ffff00',
      navy: '#000080',
      blue: '#0000ff',
      teal: '#008080',
      aqua: '#00ffff',
      orange: '#ffa500',
      aliceblue: '#f0f8ff',
      antiquewhite: '#faebd7',
      aquamarine: '#7fffd4',
      azure: '#f0ffff',
      beige: '#f5f5dc',
      bisque: '#ffe4c4',
      blanchedalmond: '#ffebcd',
      blueviolet: '#8a2be2',
      brown: '#a52a2a',
      burlywood: '#deb887',
      cadetblue: '#5f9ea0',
      chartreuse: '#7fff00',
      chocolate: '#d2691e',
      coral: '#ff7f50',
      cornflowerblue: '#6495ed',
      cornsilk: '#fff8dc',
      crimson: '#dc143c',
      cyan: '#00ffff',
      darkblue: '#00008b',
      darkcyan: '#008b8b',
      darkgoldenrod: '#b8860b',
      darkgray: '#a9a9a9',
      darkgreen: '#006400',
      darkgrey: '#a9a9a9',
      darkkhaki: '#bdb76b',
      darkmagenta: '#8b008b',
      darkolivegreen: '#556b2f',
      darkorange: '#ff8c00',
      darkorchid: '#9932cc',
      darkred: '#8b0000',
      darksalmon: '#e9967a',
      darkseagreen: '#8fbc8f',
      darkslateblue: '#483d8b',
      darkslategray: '#2f4f4f',
      darkslategrey: '#2f4f4f',
      darkturquoise: '#00ced1',
      darkviolet: '#9400d3',
      deeppink: '#ff1493',
      deepskyblue: '#00bfff',
      dimgray: '#696969',
      dimgrey: '#696969',
      dodgerblue: '#1e90ff',
      firebrick: '#b22222',
      floralwhite: '#fffaf0',
      forestgreen: '#228b22',
      gainsboro: '#dcdcdc',
      ghostwhite: '#f8f8ff',
      gold: '#ffd700',
      goldenrod: '#daa520',
      greenyellow: '#adff2f',
      grey: '#808080',
      honeydew: '#f0fff0',
      hotpink: '#ff69b4',
      indianred: '#cd5c5c',
      indigo: '#4b0082',
      ivory: '#fffff0',
      khaki: '#f0e68c',
      lavender: '#e6e6fa',
      lavenderblush: '#fff0f5',
      lawngreen: '#7cfc00',
      lemonchiffon: '#fffacd',
      lightblue: '#add8e6',
      lightcoral: '#f08080',
      lightcyan: '#e0ffff',
      lightgoldenrodyellow: '#fafad2',
      lightgray: '#d3d3d3',
      lightgreen: '#90ee90',
      lightgrey: '#d3d3d3',
      lightpink: '#ffb6c1',
      lightsalmon: '#ffa07a',
      lightseagreen: '#20b2aa',
      lightskyblue: '#87cefa',
      lightslategray: '#778899',
      lightslategrey: '#778899',
      lightsteelblue: '#b0c4de',
      lightyellow: '#ffffe0',
      limegreen: '#32cd32',
      linen: '#faf0e6',
      magenta: '#ff00ff',
      mediumaquamarine: '#66cdaa',
      mediumblue: '#0000cd',
      mediumorchid: '#ba55d3',
      mediumpurple: '#9370db',
      mediumseagreen: '#3cb371',
      mediumslateblue: '#7b68ee',
      mediumspringgreen: '#00fa9a',
      mediumturquoise: '#48d1cc',
      mediumvioletred: '#c71585',
      midnightblue: '#191970',
      mintcream: '#f5fffa',
      mistyrose: '#ffe4e1',
      moccasin: '#ffe4b5',
      navajowhite: '#ffdead',
      oldlace: '#fdf5e6',
      olivedrab: '#6b8e23',
      orangered: '#ff4500',
      orchid: '#da70d6',
      palegoldenrod: '#eee8aa',
      palegreen: '#98fb98',
      paleturquoise: '#afeeee',
      palevioletred: '#db7093',
      papayawhip: '#ffefd5',
      peachpuff: '#ffdab9',
      peru: '#cd853f',
      pink: '#ffc0cb',
      plum: '#dda0dd',
      powderblue: '#b0e0e6',
      rosybrown: '#bc8f8f',
      royalblue: '#4169e1',
      saddlebrown: '#8b4513',
      salmon: '#fa8072',
      sandybrown: '#f4a460',
      seagreen: '#2e8b57',
      seashell: '#fff5ee',
      sienna: '#a0522d',
      skyblue: '#87ceeb',
      slateblue: '#6a5acd',
      slategray: '#708090',
      slategrey: '#708090',
      snow: '#fffafa',
      springgreen: '#00ff7f',
      steelblue: '#4682b4',
      tan: '#d2b48c',
      thistle: '#d8bfd8',
      tomato: '#ff6347',
      turquoise: '#40e0d0',
      violet: '#ee82ee',
      wheat: '#f5deb3',
      whitesmoke: '#f5f5f5',
      yellowgreen: '#9acd32',
      rebeccapurple: '#663399'
    };
    var ColorTypeError = /*#__PURE__*/function (_Error) {
      _inherits(ColorTypeError, _Error);
      var _super = _createSuper(ColorTypeError);
      function ColorTypeError() {
        _classCallCheck(this, ColorTypeError);
        return _super.call(this, 'ColorTypeError: type must be hex(a), rgb(a) or hsl(a)');
      }
      return _createClass(ColorTypeError);
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    var Color = /*#__PURE__*/function (_Symbol$toString) {
      function Color() {
        var _this = this;
        _classCallCheck(this, Color);
        if (arguments.length > 0) {
          return Color.parse.apply(Color, arguments);
        }
        this.$channels = new Uint8Array(colorChannels.length);
        colorChannels.forEach(function (channel, index) {
          Object.defineProperty(_this, channel, {
            get: function get() {
              return _this.$channels[index];
            },
            set: function set(_byte) {
              if (!Number.isNaN(_byte / 1)) {
                _this.$channels[index] = Math.min(255, Math.max(0, _byte));
              }
            },
            enumerable: true,
            configurable: true
          });
        })
        // Required for observability
        ;
        ['hue', 'saturation', 'lightness'].forEach(function (name) {
          var capitalizedName = name.replace(/^./, function (m) {
            return m.toUpperCase();
          });
          Object.defineProperty(_this, name, {
            get: function get() {
              return _this["get".concat(capitalizedName)]();
            },
            set: function set(value) {
              if (!Number.isNaN(value / 1)) {
                _this["set".concat(capitalizedName)](value);
              }
            },
            enumerable: true,
            configurable: true
          });
        });
      }
      _createClass(Color, [{
        key: "getHue",
        value: function getHue() {
          var _Array$from$map = Array.from(this.$channels).map(function (c) {
              return c / 255;
            }),
            _Array$from$map2 = _slicedToArray(_Array$from$map, 3),
            red = _Array$from$map2[0],
            green = _Array$from$map2[1],
            blue = _Array$from$map2[2];
          var _ref = [Math.min(red, green, blue), Math.max(red, green, blue)],
            min = _ref[0],
            max = _ref[1];
          var delta = max - min;
          var hue = 0;
          if (delta === 0) {
            return hue;
          }
          if (red === max) {
            hue = (green - blue) / delta % 6;
          } else if (green === max) {
            hue = (blue - red) / delta + 2;
          } else {
            hue = (red - green) / delta + 4;
          }
          hue *= 60;
          while (hue !== -Infinity && hue < 0) hue += 360;
          return Math.round(hue % 360);
        }
      }, {
        key: "setHue",
        value: function setHue(value) {
          var color = Color.fromHSL(value, this.saturation, this.lightness, this.alpha / 255);
          for (var i = 0; i < this.$channels.length; i++) {
            this.$channels[i] = Number(color.$channels[i]);
          }
        }
      }, {
        key: "getSaturation",
        value: function getSaturation() {
          var _Array$from$map3 = Array.from(this.$channels).map(function (c) {
              return c / 255;
            }),
            _Array$from$map4 = _slicedToArray(_Array$from$map3, 3),
            red = _Array$from$map4[0],
            green = _Array$from$map4[1],
            blue = _Array$from$map4[2];
          var _ref2 = [Math.min(red, green, blue), Math.max(red, green, blue)],
            min = _ref2[0],
            max = _ref2[1];
          var delta = max - min;
          return delta !== 0 ? Math.round(delta / (1 - Math.abs(2 * this.lightness - 1)) * 100) / 100 : 0;
        }
      }, {
        key: "setSaturation",
        value: function setSaturation(value) {
          var _this2 = this;
          var color = Color.fromHSL(this.hue, value, this.lightness, this.alpha / 255);
          colorChannels.forEach(function (_, i) {
            return _this2.$channels[i] = color.$channels[i];
          });
        }
      }, {
        key: "getLightness",
        value: function getLightness() {
          var _Array$from$map5 = Array.from(this.$channels).map(function (c) {
              return c / 255;
            }),
            _Array$from$map6 = _slicedToArray(_Array$from$map5, 3),
            red = _Array$from$map6[0],
            green = _Array$from$map6[1],
            blue = _Array$from$map6[2];
          var _ref3 = [Math.min(red, green, blue), Math.max(red, green, blue)],
            min = _ref3[0],
            max = _ref3[1];
          return Math.round((max + min) / 2 * 100) / 100;
        }
      }, {
        key: "setLightness",
        value: function setLightness(value) {
          var _this3 = this;
          var color = Color.fromHSL(this.hue, this.lightness, value, this.alpha / 255);
          colorChannels.forEach(function (_, i) {
            return _this3.$channels[i] = color.$channels[i];
          });
        }
      }, {
        key: "clone",
        value: function clone() {
          var _this4 = this;
          var color = new Color();
          colorChannels.forEach(function (_, i) {
            return color.$channels[i] = _this4.$channels[i];
          });
          return color;
        }
      }, {
        key: "toString",
        value: function toString() {
          var _this5 = this;
          var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hex';
          switch (String(type).toLowerCase()) {
            case 'hex':
              return '#' + colorChannels.slice(0, 3).map(function (channel) {
                return _this5[channel].toString(16).padStart(2, '0');
              }).join('');
            case 'hexa':
              return '#' + colorChannels.map(function (channel) {
                return _this5[channel].toString(16).padStart(2, '0');
              }).join('');
            case 'rgb':
              return "rgb(".concat(this.red, ", ").concat(this.green, ", ").concat(this.blue, ")");
            case 'rgba':
              return "rgba(".concat(this.red, ", ").concat(this.green, ", ").concat(this.blue, ", ").concat(Math.round(this.alpha / 2.55) / 100, ")");
            case 'hsl':
              return "hsl(".concat(Math.round(this.hue), "deg, ").concat(Math.round(this.saturation * 100), "%, ").concat(Math.round(this.lightness * 100), "%)");
            case 'hsla':
              return "hsla(".concat(Math.round(this.hue), "deg, ").concat(Math.round(this.saturation * 100), "%, ").concat(Math.round(this.lightness * 100), "%, ").concat(Math.round(this.alpha / 2.55) / 100, ")");
            default:
              throw new ColorTypeError();
          }
        }
      }, {
        key: _Symbol$toString,
        get: function get() {
          return this.toString('hex');
        }
      }], [{
        key: "parse",
        value: function parse() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (_typeof(args[0]) === 'object') {
            return Color.parseObject(args[0]);
          } else if (args.every(function (arg) {
            return !Number.isNaN(arg / 1);
          })) {
            var color = new Color();
            if (args.length > 3) {
              color.red = args[0];
              color.green = args[1];
              color.blue = args[2];
              if (args[3]) {
                color.alpha = args[3];
              }
            } else if (args.length === 1) {
              var index = Number(args[0]);
              return Color.parseIndex(index, index > Math.pow(2, 24) ? 3 : 4);
            }
          } else if (typeof args[0] === 'string') {
            var match = null;
            if (typeof colorsNammed[args[0].toLowerCase()] === 'string') {
              return Color.parseHex(colorsNammed[args[0].toLowerCase()]);
            } else if ((match = args[0].match(/^(#|&h|0x)?(([a-f0-9]{3,4}){1,2})$/i)) !== null) {
              return Color.parseHex(match[2]);
            } else if ((match = args[0].match(/^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(\s*,\s*(\d*\.?\d+))?\s*\)$/i)) !== null) {
              var channels = [match[1], match[2], match[3], typeof match[5] !== 'undefined' ? match[5] : 1];
              return Color.fromRGB.apply(Color, _toConsumableArray(channels.map(function (value) {
                return Number(value);
              })));
            } else if (args[0].match(/^(h(sl|wb)a?|lab|color|cmyk)\(/i)) {
              throw new Error('Color expression not implemented yet');
            }
          }
          throw new Error('Invalid color expression');
        }
      }, {
        key: "parseObject",
        value: function parseObject(object) {
          var color = new Color();
          if (object === null || _typeof(object) !== 'object') {
            return color;
          }
          if (Color.isColor(object)) {
            return object.clone();
          }
          colorChannels.forEach(function (channel) {
            if (!Number.isNaN(object[channel])) {
              color[channel] = object[channel];
            }
          });
          return color;
        }
      }, {
        key: "parseHex",
        value: function parseHex(hex) {
          if (typeof hex !== 'string') {
            throw new Error('Hex expression must be a string');
          }
          hex = hex.trim().replace(/^(0x|&h|#)/i, '');
          if (hex.length === 3 || hex.length === 4) {
            hex = hex.split('').map(function (c) {
              return c.repeat(2);
            }).join('');
          }
          if (!(hex.length === 6 || hex.length === 8)) {
            throw new Error('Incorrect Hex expression length');
          }
          var chans = hex.split(/(..)/).filter(function (value) {
            return value;
          }).map(function (value) {
            return Number.parseInt(value, 16);
          });
          if (typeof chans[3] === 'number') {
            chans[3] /= 255;
          }
          return Color.fromRGB.apply(Color, _toConsumableArray(chans));
        }
      }, {
        key: "parseIndex",
        value: function parseIndex(value) {
          var channels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
          var color = new Color();
          for (var i = 0; i < 4; i++) {
            color[colorChannels[i]] = value >> (channels - i) * 8 && 0xff;
          }
          return color;
        }
      }, {
        key: "fromRGB",
        value: function fromRGB(red, green, blue) {
          var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
          if ([red, green, blue, alpha].some(function (arg) {
            return Number.isNaN(arg / 1);
          })) {
            throw new Error('Invalid arguments');
          }
          alpha *= 255;
          var color = new Color();
          [red, green, blue, alpha].forEach(function (value, index) {
            color[colorChannels[index]] = value;
          });
          return color;
        }
      }, {
        key: "fromHSL",
        value: function fromHSL(hue, saturation, lightness) {
          var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
          if ([hue, saturation, lightness, alpha].some(function (arg) {
            return Number.isNaN(arg);
          })) {
            throw new Error('Invalid arguments');
          }
          while (hue < 0 && hue !== -Infinity) hue += 360;
          hue = hue % 360;
          saturation = Math.max(0, Math.min(1, saturation));
          lightness = Math.max(0, Math.min(1, lightness));
          alpha = Math.max(0, Math.min(1, alpha));
          var c = (1 - Math.abs(2 * lightness - 1)) * saturation;
          var x = c * (1 - Math.abs(hue / 60 % 2 - 1));
          var m = lightness - c / 2;
          var _ref4 = hue < 60 ? [c, x, 0] : hue < 120 ? [x, c, 0] : hue < 180 ? [0, c, x] : hue < 240 ? [0, x, c] : hue < 300 ? [x, 0, c] : [c, 0, x],
            _ref5 = _slicedToArray(_ref4, 3),
            r = _ref5[0],
            g = _ref5[1],
            b = _ref5[2];
          return Color.fromRGB((r + m) * 255, (g + m) * 255, (b + m) * 255, alpha);
        }
      }, {
        key: "isColor",
        value: function isColor(arg) {
          return arg instanceof Color;
        }
      }]);
      return Color;
    }(Symbol.toString);
    var Color$1 = Color;

    var findFocusable = function findFocusable(element) {
      var programmatic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (!element) {
        return null;
      }
      if (programmatic) {
        return element.querySelectorAll('*[tabindex="-1"]');
      }
      return element.querySelectorAll("a[href]:not([tabindex=\"-1\"]),\n                                     area[href],\n                                     input:not([disabled]),\n                                     select:not([disabled]),\n                                     textarea:not([disabled]),\n                                     button:not([disabled]),\n                                     iframe,\n                                     object,\n                                     embed,\n                                     *[tabindex]:not([tabindex=\"-1\"]),\n                                     *[contenteditable]");
    };
    var onKeyDown;
    var beforeMount = function beforeMount(el, _ref) {
      var _ref$value = _ref.value,
        value = _ref$value === void 0 ? true : _ref$value;
      if (value) {
        var focusable = findFocusable(el);
        var focusableProg = findFocusable(el, true);
        if (focusable && focusable.length > 0) {
          onKeyDown = function onKeyDown(event) {
            // Need to get focusable each time since it can change between key events
            // ex. changing month in a datepicker
            focusable = findFocusable(el);
            focusableProg = findFocusable(el, true);
            var firstFocusable = focusable[0];
            var lastFocusable = focusable[focusable.length - 1];
            if (event.target === firstFocusable && event.shiftKey && event.key === 'Tab') {
              event.preventDefault();
              lastFocusable.focus();
            } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === 'Tab') {
              event.preventDefault();
              firstFocusable.focus();
            }
          };
          el.addEventListener('keydown', onKeyDown);
        }
      }
    };
    var unmounted = function unmounted(el) {
      el.removeEventListener('keydown', onKeyDown);
    };
    var directive = {
      beforeMount: beforeMount,
      unmounted: unmounted
    };
    var trapFocus = directive;

    const DEFAULT_CLOSE_OPTIONS = ['escape', 'outside'];

    const DROPDOWN_INJECTION_KEY = Symbol('bdropdown');

    var script$b = {
        name: 'BDropdown',
        directives: {
            trapFocus
        },
        provide() {
            return {
                [DROPDOWN_INJECTION_KEY]: this
            }
        },
        props: {
            modelValue: {
                type: [String, Number, Boolean, Object, Array, Function],
                default: null
            },
            disabled: Boolean,
            inline: Boolean,
            scrollable: Boolean,
            maxHeight: {
                type: [String, Number],
                default: 200
            },
            position: {
                type: String,
                validator(value) {
                    return [
                        'is-top-right',
                        'is-top-left',
                        'is-bottom-left',
                        'is-bottom-right'
                    ].indexOf(value) > -1
                }
            },
            triggers: {
                type: Array,
                default: () => ['click']
            },
            mobileModal: {
                type: Boolean,
                default: () => {
                    return config.defaultDropdownMobileModal
                }
            },
            ariaRole: {
                type: String,
                validator(value) {
                    return [
                        'menu',
                        'list',
                        'dialog'
                    ].indexOf(value) > -1
                },
                default: null
            },
            animation: {
                type: String,
                default: 'fade'
            },
            multiple: Boolean,
            trapFocus: {
                type: Boolean,
                default: () => {
                    return config.defaultTrapFocus
                }
            },
            closeOnClick: {
                type: Boolean,
                default: true
            },
            canClose: {
                type: [Array, Boolean],
                default: true
            },
            expanded: Boolean,
            appendToBody: Boolean,
            appendToBodyCopyParent: Boolean,
            triggerTabindex: {
                type: Number,
                default: 0
            }
        },
        emits: ['active-change', 'change', 'update:modelValue'],
        data() {
            return {
                selected: this.modelValue,
                style: {},
                isActive: false,
                isHoverable: false,
                maybeTap: false,
                isTouchEnabled: false,
                _bodyEl: undefined, // Used to append to body
                timeOutID: null,
                timeOutID2: null
            }
        },
        computed: {
            rootClasses() {
                return [this.position, {
                    'is-disabled': this.disabled,
                    'is-hoverable': this.hoverable,
                    'is-inline': this.inline,
                    'is-active': this.isActive || this.inline,
                    'is-mobile-modal': this.isMobileModal,
                    'is-expanded': this.expanded,
                    'is-touch-enabled': this.isTouchEnabled
                }]
            },
            isMobileModal() {
                return this.mobileModal && !this.inline
            },
            cancelOptions() {
                return typeof this.canClose === 'boolean'
                    ? this.canClose
                        ? DEFAULT_CLOSE_OPTIONS
                        : []
                    : this.canClose
            },
            contentStyle() {
                return {
                    maxHeight: this.scrollable ? toCssWidth(this.maxHeight) : null,
                    overflow: this.scrollable ? 'auto' : null
                }
            },
            hoverable() {
                return this.triggers.indexOf('hover') >= 0
            }
        },
        watch: {
            /**
            * When v-model is changed set the new selected item.
            */
            modelValue(value) {
                this.selected = value;
            },

            /**
            * Emit event when isActive value is changed.
            *
            * Also resets `isTouchEnabled` when it turns inactive.
            */
            isActive(value) {
                this.$emit('active-change', value);
                if (!value) {
                    // delays to reset the touch enabled flag until the dropdown
                    // menu disappears to avoid glitches
                    // also takes care of chattering, e.g., repeated quick taps,
                    // otherwise the flag may become inconsistent with the actual
                    // state of the dropdown menu
                    this.timeOutID = setTimeout(() => {
                        if (!this.isActive) {
                            this.isTouchEnabled = false;
                        }
                    }, 250);
                }
                this.handleScroll();
                if (this.appendToBody) {
                    this.$nextTick(() => {
                        this.updateAppendToBody();
                    });
                }
            },

            isHoverable(value) {
                if (this.hoverable) {
                    this.$emit('active-change', value);
                }
            }
        },
        methods: {
            handleScroll() {
                if (typeof window === 'undefined') return

                if (this.isMobileModal) {
                    if (this.isActive) {
                        document.documentElement.classList.add('is-clipped-touch');
                    } else {
                        document.documentElement.classList.remove('is-clipped-touch');
                    }
                }
            },

            /**
             * Click listener from DropdownItem.
             *   1. Set new selected item.
             *   2. Emit input event to update the user v-model.
             *   3. Close the dropdown.
             */
            selectItem(value) {
                if (this.multiple) {
                    if (this.selected) {
                        if (this.selected.indexOf(value) === -1) {
                            // Add value
                            this.selected = [...this.selected, value];
                        } else {
                            // Remove value
                            this.selected = this.selected.filter((val) => val !== value);
                        }
                    } else {
                        this.selected = [value];
                    }
                    this.$emit('change', this.selected);
                } else {
                    if (this.selected !== value) {
                        this.selected = value;
                        this.$emit('change', this.selected);
                    }
                }
                this.$emit('update:modelValue', this.selected);
                if (!this.multiple) {
                    this.isActive = !this.closeOnClick;
                    if (this.hoverable && this.closeOnClick) {
                        this.isHoverable = false;
                    }
                }
            },

            /**
            * White-listed items to not close when clicked.
            */
            isInWhiteList(el) {
                if (el === this.$refs.dropdownMenu) return true
                if (el === this.$refs.trigger) return true
                // All chidren from dropdown
                if (this.$refs.dropdownMenu != null) {
                    const children = this.$refs.dropdownMenu.querySelectorAll('*');
                    for (const child of children) {
                        if (el === child) {
                            return true
                        }
                    }
                }
                // All children from trigger
                if (this.$refs.trigger != null) {
                    const children = this.$refs.trigger.querySelectorAll('*');
                    for (const child of children) {
                        if (el === child) {
                            return true
                        }
                    }
                }
                return false
            },

            /**
            * Close dropdown if clicked outside.
            */
            clickedOutside(event) {
                if (this.cancelOptions.indexOf('outside') < 0) return
                if (this.inline) return

                const target = isCustomElement(this) ? event.composedPath()[0] : event.target;
                if (!this.isInWhiteList(target)) this.isActive = false;
            },

            /**
             * Keypress event that is bound to the document
             */
            keyPress({ key }) {
                if (this.isActive && (key === 'Escape' || key === 'Esc')) {
                    if (this.cancelOptions.indexOf('escape') < 0) return
                    this.isActive = false;
                }
            },

            onClick() {
                // hover precedes
                if (this.triggers.indexOf('hover') !== -1) return
                if (this.triggers.indexOf('click') < 0) return
                this.toggle();
            },
            onContextMenu() {
                if (this.triggers.indexOf('contextmenu') < 0) return
                this.toggle();
            },
            onHover() {
                if (this.triggers.indexOf('hover') < 0) return
                // touch precedes
                if (this.isTouchEnabled) return
                this.isHoverable = true;
            },
            // takes care of touch-enabled devices
            // - does nothing if hover trigger is disabled
            // - suppresses hover trigger by setting isTouchEnabled
            // - handles only a tap; i.e., touchstart on the trigger immediately
            //   folowed by touchend
            onTouchStart() {
                this.maybeTap = true;
            },
            onTouchMove() {
                this.maybeTap = false;
            },
            onTouchEnd(e) {
                if (this.triggers.indexOf('hover') === -1) return
                if (!this.maybeTap) return
                // tap on dropdown contents may happen without preventDefault
                e.preventDefault();
                this.maybeTap = false;
                this.isTouchEnabled = true;
                this.toggle();
            },
            onFocus() {
                if (this.triggers.indexOf('focus') < 0) return
                this.toggle();
            },

            /**
            * Toggle dropdown if it's not disabled.
            */
            toggle() {
                if (this.disabled) return

                if (!this.isActive) {
                    // if not active, toggle after clickOutside event
                    // this fixes toggling programmatic
                    // $nextTick may not wait for other events since Vue 3.
                    this.timeOutID2 = setTimeout(() => {
                        const value = !this.isActive;
                        this.isActive = value;
                    });
                } else {
                    this.isActive = !this.isActive;
                }
            },

            updateAppendToBody() {
                const dropdown = this.$refs.dropdown;
                const dropdownMenu = this.$refs.dropdownMenu;
                const trigger = this.$refs.trigger;
                if (dropdownMenu && trigger) {
                    // update wrapper dropdown
                    const dropdownWrapper = this.$data._bodyEl.children[0];
                    dropdownWrapper.classList.forEach((item) => dropdownWrapper.classList.remove(item));
                    dropdownWrapper.classList.add('dropdown');
                    dropdownWrapper.classList.add('dropdown-menu-animation');
                    // TODO: the following test never becomes true on Vue 3.
                    //       I have no idea about the intention of it.
                    if (this.$vnode && this.$vnode.data && this.$vnode.data.staticClass) {
                        dropdownWrapper.classList.add(this.$vnode.data.staticClass);
                    }
                    this.rootClasses.forEach((item) => {
                        // skip position prop
                        if (item && typeof item === 'object') {
                            for (const key in item) {
                                if (item[key]) {
                                    dropdownWrapper.classList.add(key);
                                }
                            }
                        }
                    });
                    if (this.appendToBodyCopyParent) {
                        const parentNode = this.$refs.dropdown.parentNode;
                        const parent = this.$data._bodyEl;
                        parent.classList.forEach((item) => parent.classList.remove(item));
                        parentNode.classList.forEach((item) => {
                            parent.classList.add(item);
                        });
                    }
                    const rect = trigger.getBoundingClientRect();
                    let top = rect.top + window.scrollY;
                    let left = rect.left + window.scrollX;
                    if (!this.position || this.position.indexOf('bottom') >= 0) {
                        top += trigger.clientHeight;
                    } else {
                        top -= dropdownMenu.clientHeight;
                    }
                    if (this.position && this.position.indexOf('left') >= 0) {
                        left -= (dropdownMenu.clientWidth - trigger.clientWidth);
                    }
                    this.style = {
                        position: 'absolute',
                        top: `${top}px`,
                        left: `${left}px`,
                        zIndex: '99',
                        width: this.expanded ? `${dropdown.offsetWidth}px` : undefined
                    };
                }
            }
        },
        mounted() {
            if (this.appendToBody) {
                this.$data._bodyEl = createAbsoluteElement(this.$refs.dropdownMenu);
                this.updateAppendToBody();
            }
        },
        created() {
            if (typeof window !== 'undefined') {
                document.addEventListener('click', this.clickedOutside);
                document.addEventListener('keyup', this.keyPress);
            }
        },
        beforeUnmount() {
            if (typeof window !== 'undefined') {
                document.removeEventListener('click', this.clickedOutside);
                document.removeEventListener('keyup', this.keyPress);
            }
            if (this.appendToBody) {
                removeElement(this.$data._bodyEl);
            }
            clearTimeout(this.timeOutID);
            clearTimeout(this.timeOutID2);
        }
    };

    const _hoisted_1$8 = ["tabindex"];
    const _hoisted_2$6 = ["aria-hidden"];
    const _hoisted_3$4 = ["aria-hidden"];
    const _hoisted_4$2 = ["role", "aria-modal"];

    function render$a(_ctx, _cache, $props, $setup, $data, $options) {
      const _directive_trap_focus = vue.resolveDirective("trap-focus");

      return (vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["dropdown dropdown-menu-animation", $options.rootClasses]),
        ref: "dropdown",
        onMouseleave: _cache[7] || (_cache[7] = $event => ($data.isHoverable = false))
      }, [
        (!$props.inline)
          ? (vue.openBlock(), vue.createElementBlock("div", {
              key: 0,
              tabindex: $props.disabled ? false : $props.triggerTabindex,
              ref: "trigger",
              class: "dropdown-trigger",
              onClick: _cache[0] || (_cache[0] = (...args) => ($options.onClick && $options.onClick(...args))),
              onContextmenu: _cache[1] || (_cache[1] = vue.withModifiers((...args) => ($options.onContextMenu && $options.onContextMenu(...args)), ["prevent"])),
              onMouseenter: _cache[2] || (_cache[2] = (...args) => ($options.onHover && $options.onHover(...args))),
              onFocusCapture: _cache[3] || (_cache[3] = (...args) => ($options.onFocus && $options.onFocus(...args))),
              onTouchstart: _cache[4] || (_cache[4] = (...args) => ($options.onTouchStart && $options.onTouchStart(...args))),
              onTouchmove: _cache[5] || (_cache[5] = (...args) => ($options.onTouchMove && $options.onTouchMove(...args))),
              onTouchend: _cache[6] || (_cache[6] = (...args) => ($options.onTouchEnd && $options.onTouchEnd(...args))),
              "aria-haspopup": "true"
            }, [
              vue.renderSlot(_ctx.$slots, "trigger", { active: $data.isActive })
            ], 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_1$8))
          : vue.createCommentVNode("v-if", true),
        vue.createVNode(vue.Transition, { name: $props.animation }, {
          default: vue.withCtx(() => [
            ($options.isMobileModal)
              ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
                  key: 0,
                  class: "background",
                  "aria-hidden": !$data.isActive
                }, null, 8 /* PROPS */, _hoisted_2$6)), [
                  [vue.vShow, $data.isActive]
                ])
              : vue.createCommentVNode("v-if", true)
          ]),
          _: 1 /* STABLE */
        }, 8 /* PROPS */, ["name"]),
        vue.createVNode(vue.Transition, {
          name: $props.animation,
          persisted: ""
        }, {
          default: vue.withCtx(() => [
            vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
              ref: "dropdownMenu",
              class: "dropdown-menu",
              style: vue.normalizeStyle($data.style),
              "aria-hidden": !$data.isActive
            }, [
              vue.createElementVNode("div", {
                class: "dropdown-content",
                role: $props.ariaRole,
                "aria-modal": !$props.inline,
                style: vue.normalizeStyle($options.contentStyle)
              }, [
                vue.renderSlot(_ctx.$slots, "default")
              ], 12 /* STYLE, PROPS */, _hoisted_4$2)
            ], 12 /* STYLE, PROPS */, _hoisted_3$4)), [
              [vue.vShow, (!$props.disabled && ($data.isActive || $data.isHoverable)) || $props.inline],
              [_directive_trap_focus, $props.trapFocus]
            ])
          ]),
          _: 3 /* FORWARDED */
        }, 8 /* PROPS */, ["name"])
      ], 34 /* CLASS, HYDRATE_EVENTS */))
    }

    script$b.render = render$a;
    script$b.__file = "src/components/dropdown/Dropdown.vue";

    var script$a = {
        name: 'BDropdownItem',
        inject: {
            parent: {
                from: DROPDOWN_INJECTION_KEY,
                default: undefined
            }
        },
        props: {
            value: {
                type: [String, Number, Boolean, Object, Array, Function],
                default: null
            },
            separator: Boolean,
            disabled: Boolean,
            custom: Boolean,
            focusable: {
                type: Boolean,
                default: true
            },
            paddingless: Boolean,
            hasLink: Boolean,
            ariaRole: {
                type: String,
                default: ''
            }
        },
        emits: ['click'],
        computed: {
            anchorClasses() {
                return {
                    'is-disabled': this.parent.disabled || this.disabled,
                    'is-paddingless': this.paddingless,
                    'is-active': this.isActive
                }
            },
            itemClasses() {
                return {
                    'dropdown-item': !this.hasLink,
                    'is-disabled': this.disabled,
                    'is-paddingless': this.paddingless,
                    'is-active': this.isActive,
                    'has-link': this.hasLink
                }
            },
            ariaRoleItem() {
                return this.ariaRole === 'menuitem' || this.ariaRole === 'listitem' ? this.ariaRole : null
            },
            isClickable() {
                return !this.parent.disabled && !this.separator && !this.disabled && !this.custom
            },
            isActive() {
                if (this.parent.selected === null) return false
                if (this.parent.multiple) return this.parent.selected.indexOf(this.value) >= 0
                return this.value === this.parent.selected
            },
            isFocusable() {
                return this.hasLink ? false : this.focusable
            }
        },
        methods: {
            /**
            * Click listener, select the item.
            */
            selectItem() {
                if (!this.isClickable) return

                this.parent.selectItem(this.value);
                this.$emit('click');
            }
        }
    };

    const _hoisted_1$7 = {
      key: 0,
      class: "dropdown-divider"
    };
    const _hoisted_2$5 = ["role", "tabindex"];
    const _hoisted_3$3 = ["role", "tabindex"];

    function render$9(_ctx, _cache, $props, $setup, $data, $options) {
      return ($props.separator)
        ? (vue.openBlock(), vue.createElementBlock("hr", _hoisted_1$7))
        : (!$props.custom && !$props.hasLink)
          ? (vue.openBlock(), vue.createElementBlock("a", {
              key: 1,
              class: vue.normalizeClass(["dropdown-item", $options.anchorClasses]),
              onClick: _cache[0] || (_cache[0] = (...args) => ($options.selectItem && $options.selectItem(...args))),
              role: $options.ariaRoleItem,
              tabindex: $options.isFocusable ? 0 : null
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 10 /* CLASS, PROPS */, _hoisted_2$5))
          : (vue.openBlock(), vue.createElementBlock("div", {
              key: 2,
              class: vue.normalizeClass($options.itemClasses),
              onClick: _cache[1] || (_cache[1] = (...args) => ($options.selectItem && $options.selectItem(...args))),
              role: $options.ariaRoleItem,
              tabindex: $options.isFocusable ? 0 : null
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 10 /* CLASS, PROPS */, _hoisted_3$3))
    }

    script$a.render = render$9;
    script$a.__file = "src/components/dropdown/DropdownItem.vue";

    var mdiIcons = {
      sizes: {
        "default": 'mdi-24px',
        'is-small': null,
        'is-medium': 'mdi-36px',
        'is-large': 'mdi-48px'
      },
      iconPrefix: 'mdi-'
    };
    var faIcons = function faIcons() {
      var faIconPrefix = config && config.defaultIconComponent ? '' : 'fa-';
      return {
        sizes: {
          "default": null,
          'is-small': null,
          'is-medium': faIconPrefix + 'lg',
          'is-large': faIconPrefix + '2x'
        },
        iconPrefix: faIconPrefix,
        internalIcons: {
          information: 'info-circle',
          alert: 'exclamation-triangle',
          'alert-circle': 'exclamation-circle',
          'chevron-right': 'angle-right',
          'chevron-left': 'angle-left',
          'chevron-down': 'angle-down',
          'eye-off': 'eye-slash',
          'menu-down': 'caret-down',
          'menu-up': 'caret-up',
          'close-circle': 'times-circle'
        }
      };
    };
    var getIcons = function getIcons() {
      var icons = {
        mdi: mdiIcons,
        fa: faIcons(),
        fas: faIcons(),
        far: faIcons(),
        fad: faIcons(),
        fab: faIcons(),
        fal: faIcons(),
        'fa-solid': faIcons(),
        'fa-regular': faIcons(),
        'fa-light': faIcons(),
        'fa-thin': faIcons(),
        'fa-duotone': faIcons(),
        'fa-brands': faIcons()
      };
      if (config && config.customIconPacks) {
        icons = merge(icons, config.customIconPacks, true);
      }
      return icons;
    };
    var getIcons$1 = getIcons;

    var script$9 = {
        name: 'BIcon',
        props: {
            type: [String, Object],
            component: String,
            pack: String,
            icon: String,
            size: String,
            customSize: String,
            customClass: String,
            both: Boolean // This is used internally to show both MDI and FA icon
        },
        computed: {
            iconConfig() {
                const allIcons = getIcons$1();
                return allIcons[this.newPack]
            },
            iconPrefix() {
                if (this.iconConfig && this.iconConfig.iconPrefix) {
                    return this.iconConfig.iconPrefix
                }
                return ''
            },
            /**
            * Internal icon name based on the pack.
            * If pack is 'fa', gets the equivalent FA icon name of the MDI,
            * internal icons are always MDI.
            */
            newIcon() {
                return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`
            },
            newPack() {
                return this.pack || config.defaultIconPack
            },
            newType() {
                if (!this.type) return

                let splitType = [];
                if (typeof this.type === 'string') {
                    splitType = this.type.split('-');
                } else {
                    for (const key in this.type) {
                        if (this.type[key]) {
                            splitType = key.split('-');
                            break
                        }
                    }
                }
                if (splitType.length <= 1) return

                const [, ...type] = splitType;
                return `has-text-${type.join('-')}`
            },
            newCustomSize() {
                return this.customSize || this.customSizeByPack
            },
            customSizeByPack() {
                if (this.iconConfig && this.iconConfig.sizes) {
                    if (this.size && this.iconConfig.sizes[this.size] !== undefined) {
                        return this.iconConfig.sizes[this.size]
                    } else if (this.iconConfig.sizes.default) {
                        return this.iconConfig.sizes.default
                    }
                }
                return null
            },
            useIconComponent() {
                return this.component || config.defaultIconComponent
            }
        },
        methods: {
            /**
            * Equivalent icon name of the MDI.
            */
            getEquivalentIconOf(value) {
                // Only transform the class if the both prop is set to true
                if (!this.both) {
                    return value
                }

                if (this.iconConfig &&
                    this.iconConfig.internalIcons &&
                    this.iconConfig.internalIcons[value]) {
                    return this.iconConfig.internalIcons[value]
                }
                return value
            }
        }
    };

    function render$8(_ctx, _cache, $props, $setup, $data, $options) {
      return (vue.openBlock(), vue.createElementBlock("span", {
        class: vue.normalizeClass(["icon", [$options.newType, $props.size]])
      }, [
        (!$options.useIconComponent)
          ? (vue.openBlock(), vue.createElementBlock("i", {
              key: 0,
              class: vue.normalizeClass([$options.newPack, $options.newIcon, $options.newCustomSize, $props.customClass])
            }, null, 2 /* CLASS */))
          : (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent($options.useIconComponent), {
              key: 1,
              icon: [$options.newPack, $options.newIcon],
              size: $options.newCustomSize,
              class: vue.normalizeClass([$props.customClass])
            }, null, 8 /* PROPS */, ["icon", "size", "class"]))
      ], 2 /* CLASS */))
    }

    script$9.render = render$8;
    script$9.__file = "src/components/icon/Icon.vue";

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }

    var _excluded = ["style", "class", "id"];
    var CompatFallthroughMixin = {
      inheritAttrs: false,
      props: {
        compatFallthrough: {
          type: Boolean,
          "default": function _default() {
            return config.defaultCompatFallthrough;
          }
        }
      },
      computed: {
        rootAttrs: function rootAttrs() {
          return this.compatFallthrough ? {
            "class": this.$attrs["class"],
            style: this.$attrs.style,
            id: this.$attrs.id
          } : {};
        },
        fallthroughAttrs: function fallthroughAttrs() {
          if (this.compatFallthrough) {
            var _this$$attrs = this.$attrs;
              _this$$attrs.style;
              _this$$attrs["class"];
              _this$$attrs.id;
              var rest = _objectWithoutProperties(_this$$attrs, _excluded);
            return rest;
          } else {
            return this.$attrs;
          }
        }
      }
    };

    var script$8 = {
        name: 'BInput',
        components: {
            [script$9.name]: script$9
        },
        mixins: [CompatFallthroughMixin, FormElementMixin],
        props: {
            modelValue: [Number, String],
            type: {
                type: String,
                default: 'text'
            },
            lazy: {
                type: Boolean,
                default: false
            },
            passwordReveal: Boolean,
            iconClickable: Boolean,
            hasCounter: {
                type: Boolean,
                default: () => config.defaultInputHasCounter
            },
            customClass: {
                type: String,
                default: ''
            },
            iconRight: String,
            iconRightClickable: Boolean,
            iconRightType: String
        },
        emits: [
            'icon-click',
            'icon-right-click',
            'update:modelValue'
        ],
        data() {
            return {
                newValue: this.modelValue,
                newType: this.type,
                newAutocomplete: this.autocomplete || config.defaultInputAutocomplete,
                isPasswordVisible: false,
                _elementRef: this.type === 'textarea'
                    ? 'textarea'
                    : 'input'
            }
        },
        computed: {
            computedValue: {
                get() {
                    return this.newValue
                },
                set(value) {
                    this.newValue = value;
                    this.$emit('update:modelValue', value);
                }
            },
            rootClasses() {
                return [
                    this.iconPosition,
                    this.size,
                    {
                        'is-expanded': this.expanded,
                        'is-loading': this.loading,
                        'is-clearfix': !this.hasMessage
                    }
                ]
            },
            inputClasses() {
                return [
                    this.statusType,
                    this.size,
                    { 'is-rounded': this.rounded }
                ]
            },
            hasIconRight() {
                return this.passwordReveal ||
                    this.loading || (this.statusIcon && this.statusTypeIcon) || this.iconRight
            },
            rightIcon() {
                if (this.passwordReveal) {
                    return this.passwordVisibleIcon
                } else if (this.iconRight) {
                    return this.iconRight
                }
                return this.statusTypeIcon
            },
            rightIconType() {
                if (this.passwordReveal) {
                    return 'is-primary'
                } else if (this.iconRight) {
                    return this.iconRightType || null
                }
                return this.statusType
            },

            /**
            * Position of the icon or if it's both sides.
            */
            iconPosition() {
                let iconClasses = '';

                if (this.icon) {
                    iconClasses += 'has-icons-left ';
                }

                if (this.hasIconRight) {
                    iconClasses += 'has-icons-right';
                }

                return iconClasses
            },

            /**
            * Icon name (MDI) based on the type.
            */
            statusTypeIcon() {
                switch (this.statusType) {
                    case 'is-success': return 'check'
                    case 'is-danger': return 'alert-circle'
                    case 'is-info': return 'information'
                    case 'is-warning': return 'alert'
                    default: return undefined
                }
            },

            /**
            * Check if have any message prop from parent if it's a Field.
            */
            hasMessage() {
                return !!this.statusMessage
            },

            /**
            * Current password-reveal icon name.
            */
            passwordVisibleIcon() {
                return !this.isPasswordVisible ? 'eye' : 'eye-off'
            },
            /**
            * Get value length
            */
            valueLength() {
                if (typeof this.computedValue === 'string') {
                    return Array.from(this.computedValue).length
                } else if (typeof this.computedValue === 'number') {
                    return this.computedValue.toString().length
                }
                return 0
            }
        },
        watch: {
            /**
            * When v-model is changed:
            *   1. Set internal value.
            *   2. Validate it if the value came from outside;
            *      i.e., not equal to computedValue
            */
            modelValue(value) {
                const fromOutside = this.computedValue != value; // eslint-disable-line eqeqeq
                this.newValue = value;
                if (fromOutside) {
                    // validation must wait for DOM updated
                    this.$nextTick(() => {
                        !this.isValid && this.checkHtml5Validity();
                    });
                }
            },
            type(type) {
                this.newType = type;
            }
        },
        methods: {
            /**
            * Toggle the visibility of a password-reveal input
            * by changing the type and focus the input right away.
            */
            togglePasswordVisibility() {
                this.isPasswordVisible = !this.isPasswordVisible;
                this.newType = this.isPasswordVisible ? 'text' : 'password';

                this.$nextTick(() => {
                    this.focus();
                });
            },

            iconClick(emit, event) {
                this.$emit(emit, event);
                this.$nextTick(() => {
                    this.focus();
                });
            },

            rightIconClick(event) {
                if (this.passwordReveal) {
                    this.togglePasswordVisibility();
                } else if (this.iconRightClickable) {
                    this.iconClick('icon-right-click', event);
                }
            },

            onInput(event) {
                if (!this.lazy) {
                    const value = event.target.value;
                    this.updateValue(value);
                }
            },

            onChange(event) {
                if (this.lazy) {
                    const value = event.target.value;
                    this.updateValue(value);
                }
            },

            updateValue(value) {
                this.computedValue = value;
                !this.isValid && this.checkHtml5Validity();
            }
        }
    };

    const _hoisted_1$6 = ["type", "autocomplete", "maxlength", "value"];
    const _hoisted_2$4 = ["maxlength", "value"];

    function render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_b_icon = vue.resolveComponent("b-icon");

      return (vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({
        class: ["control", $options.rootClasses]
      }, _ctx.rootAttrs), [
        ($props.type !== 'textarea')
          ? (vue.openBlock(), vue.createElementBlock("input", vue.mergeProps({
              key: 0,
              ref: "input",
              class: ["input", [$options.inputClasses, $props.customClass]],
              type: $data.newType,
              autocomplete: $data.newAutocomplete,
              maxlength: _ctx.maxlength,
              value: $options.computedValue
            }, _ctx.fallthroughAttrs, {
              onInput: _cache[0] || (_cache[0] = (...args) => ($options.onInput && $options.onInput(...args))),
              onChange: _cache[1] || (_cache[1] = (...args) => ($options.onChange && $options.onChange(...args))),
              onBlur: _cache[2] || (_cache[2] = (...args) => (_ctx.onBlur && _ctx.onBlur(...args))),
              onFocus: _cache[3] || (_cache[3] = (...args) => (_ctx.onFocus && _ctx.onFocus(...args)))
            }), null, 16 /* FULL_PROPS */, _hoisted_1$6))
          : (vue.openBlock(), vue.createElementBlock("textarea", vue.mergeProps({
              key: 1,
              ref: "textarea",
              class: ["textarea", [$options.inputClasses, $props.customClass]],
              maxlength: _ctx.maxlength,
              value: $options.computedValue
            }, _ctx.fallthroughAttrs, {
              onInput: _cache[4] || (_cache[4] = (...args) => ($options.onInput && $options.onInput(...args))),
              onChange: _cache[5] || (_cache[5] = (...args) => ($options.onChange && $options.onChange(...args))),
              onBlur: _cache[6] || (_cache[6] = (...args) => (_ctx.onBlur && _ctx.onBlur(...args))),
              onFocus: _cache[7] || (_cache[7] = (...args) => (_ctx.onFocus && _ctx.onFocus(...args)))
            }), null, 16 /* FULL_PROPS */, _hoisted_2$4)),
        (_ctx.icon)
          ? (vue.openBlock(), vue.createBlock(_component_b_icon, {
              key: 2,
              class: vue.normalizeClass(["is-left", {'is-clickable': $props.iconClickable}]),
              icon: _ctx.icon,
              pack: _ctx.iconPack,
              size: _ctx.iconSize,
              onClick: _cache[8] || (_cache[8] = $event => ($options.iconClick('icon-click', $event)))
            }, null, 8 /* PROPS */, ["class", "icon", "pack", "size"]))
          : vue.createCommentVNode("v-if", true),
        (!_ctx.loading && $options.hasIconRight)
          ? (vue.openBlock(), vue.createBlock(_component_b_icon, {
              key: 3,
              class: vue.normalizeClass(["is-right", { 'is-clickable': $props.passwordReveal || $props.iconRightClickable }]),
              icon: $options.rightIcon,
              pack: _ctx.iconPack,
              size: _ctx.iconSize,
              type: $options.rightIconType,
              both: "",
              onClick: $options.rightIconClick
            }, null, 8 /* PROPS */, ["class", "icon", "pack", "size", "type", "onClick"]))
          : vue.createCommentVNode("v-if", true),
        (_ctx.maxlength && $props.hasCounter && $props.type !== 'number')
          ? (vue.openBlock(), vue.createElementBlock("small", {
              key: 4,
              class: vue.normalizeClass(["help counter", { 'is-invisible': !_ctx.isFocused }])
            }, vue.toDisplayString($options.valueLength) + " / " + vue.toDisplayString(_ctx.maxlength), 3 /* TEXT, CLASS */))
          : vue.createCommentVNode("v-if", true)
      ], 16 /* FULL_PROPS */))
    }

    script$8.render = render$7;
    script$8.__file = "src/components/input/Input.vue";

    var script$7 = {
        name: 'BFieldBody',
        inject: {
            parent: {
                from: 'BField',
                default: null
            }
        },
        props: {
            message: {
                type: [String, Array]
            },
            type: {
                type: [String, Object]
            }
        },
        render() {
            let first = true;
            // wraps the default slot (children) with `b-field`.
            // children may be given in a fragment and should be extracted.
            let children = typeof this.$slots.default === 'function'
                ? this.$slots.default()
                : this.$slots.default;
            if (children != null && children.length === 1 && children[0].type === vue.Fragment) {
                children = children[0].children;
            }
            return vue.h(
                'div',
                { class: 'field-body' },
                {
                    default: () => {
                        return children != null && children.map((element) => {
                            // skip returns(?) and comments
                            if (element.type === vue.Comment || element.type === vue.Text) {
                                return element
                            }
                            let message;
                            if (first) {
                                message = this.message;
                                first = false;
                            }
                            return vue.h(
                                this.parent ? this.parent.$.type : vue.resolveComponent('b-field'),
                                {
                                    type: this.type,
                                    message
                                },
                                () => element
                            )
                        })
                    }
                }
            )
        }
    };

    script$7.__file = "src/components/field/FieldBody.vue";

    var script$6 = {
        name: 'BField',
        components: {
            [script$7.name]: script$7
        },
        provide() {
            return {
                BField: this
            }
        },
        inject: {
            parent: {
                from: 'BField',
                default: false
            }
        }, // Used internally only when using Field in Field
        props: {
            type: [String, Object],
            label: String,
            labelFor: String,
            message: [String, Array, Object],
            grouped: Boolean,
            groupMultiline: Boolean,
            position: String,
            expanded: Boolean,
            horizontal: Boolean,
            addons: {
                type: Boolean,
                default: true
            },
            customClass: String,
            labelPosition: {
                type: String,
                default: () => { return config.defaultFieldLabelPosition }
            }
        },
        data() {
            return {
                newType: this.type,
                newMessage: this.message,
                fieldLabelSize: null,
                numberInputClasses: [],
                _isField: true // Used internally by Input and Select
            }
        },
        computed: {
            rootClasses() {
                return [{
                    'is-expanded': this.expanded,
                    'is-horizontal': this.horizontal,
                    'is-floating-in-label': this.hasLabel && !this.horizontal &&
                        this.labelPosition === 'inside',
                    'is-floating-label': this.hasLabel && !this.horizontal &&
                        this.labelPosition === 'on-border'
                },
                this.numberInputClasses]
            },
            innerFieldClasses() {
                return [
                    this.fieldType(),
                    this.newPosition,
                    {
                        'is-grouped-multiline': this.groupMultiline
                    }
                ]
            },
            hasInnerField() {
                return this.grouped || this.groupMultiline || this.hasAddons()
            },
            /**
            * Correct Bulma class for the side of the addon or group.
            *
            * This is not kept like the others (is-small, etc.),
            * because since 'has-addons' is set automatically it
            * doesn't make sense to teach users what addons are exactly.
            */
            newPosition() {
                if (this.position === undefined) return

                const position = this.position.split('-');
                if (position.length < 1) return

                const prefix = this.grouped
                    ? 'is-grouped-'
                    : 'has-addons-';

                if (this.position) return prefix + position[1]
                return undefined
            },
            /**
            * Formatted message in case it's an array
            * (each element is separated by <br> tag)
            */
            formattedMessage() {
                if (this.parent && this.parent.hasInnerField) {
                    return '' // Message will be displayed in parent field
                }
                if (typeof this.newMessage === 'string') {
                    return [this.newMessage]
                }
                const messages = [];
                if (Array.isArray(this.newMessage)) {
                    this.newMessage.forEach((message) => {
                        if (typeof message === 'string') {
                            messages.push(message);
                        } else {
                            for (const key in message) {
                                if (message[key]) {
                                    messages.push(key);
                                }
                            }
                        }
                    });
                } else {
                    for (const key in this.newMessage) {
                        if (this.newMessage[key]) {
                            messages.push(key);
                        }
                    }
                }
                return messages.filter((m) => !!m)
            },
            hasLabel() {
                return this.label || this.$slots.label
            },
            hasMessage() {
                return ((!this.parent || !this.parent.hasInnerField) && this.newMessage) ||
                    this.$slots.message
            }
        },
        watch: {
            /**
            * Set internal type when prop change.
            */
            type(value) {
                this.newType = value;
            },

            /**
            * Set internal message when prop change.
            */
            message(value) {
                // we deep comparison here becase an innner Field of another Field
                // receives the message as a brand new array every time, so simple
                // identity check won't work and will end up with infinite
                // recursions
                // https://github.com/buefy/buefy/issues/4018#issuecomment-1985026234
                if (JSON.stringify(value) !== JSON.stringify(this.newMessage)) {
                    this.newMessage = value;
                }
            },

            /**
            * Set parent message if we use Field in Field.
            */
            newMessage(value) {
                if (this.parent && this.parent.hasInnerField) {
                    if (!this.parent.type) {
                        this.parent.newType = this.newType;
                    }
                    if (!this.parent.message) {
                        this.parent.newMessage = value;
                    }
                }
            }
        },
        methods: {
            /**
            * Field has addons if there are more than one slot
            * (element / component) in the Field.
            * Or is grouped when prop is set.
            * Is a method to be called when component re-render.
            */
            fieldType() {
                if (this.grouped) return 'is-grouped'
                if (this.hasAddons()) return 'has-addons'
            },
            hasAddons() {
                let renderedNode = 0;
                if (this.$slots.default) {
                    renderedNode = this.$slots.default().reduce((i, node) => isTag(node) ? i + 1 : i, 0);
                }
                return (
                    renderedNode > 1 &&
                    this.addons &&
                    !this.horizontal
                )
            },
            // called by a number input if it is a direct child.
            wrapNumberinput({ controlsPosition, size }) {
                const classes = ['has-numberinput'];
                if (controlsPosition) {
                    classes.push(`has-numberinput-${controlsPosition}`);
                }
                if (size) {
                    classes.push(`has-numberinput-${size}`);
                }
                this.numberInputClasses = classes;
            }
        },
        mounted() {
            if (this.horizontal) {
                // Bulma docs: .is-normal for any .input or .button
                const elements = this.$el.querySelectorAll('.input, .select, .button, .textarea, .b-slider');
                if (elements.length > 0) {
                    this.fieldLabelSize = 'is-normal';
                }
            }
        }
    };

    const _hoisted_1$5 = ["for"];
    const _hoisted_2$3 = ["for"];
    const _hoisted_3$2 = {
      key: 3,
      class: "field-body"
    };

    function render$6(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_b_field_body = vue.resolveComponent("b-field-body");
      const _component_b_field = vue.resolveComponent("b-field");

      return (vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["field", $options.rootClasses])
      }, [
        ($props.horizontal)
          ? (vue.openBlock(), vue.createElementBlock("div", {
              key: 0,
              class: vue.normalizeClass(["field-label", [$props.customClass, $data.fieldLabelSize]])
            }, [
              ($options.hasLabel)
                ? (vue.openBlock(), vue.createElementBlock("label", {
                    key: 0,
                    for: $props.labelFor,
                    class: vue.normalizeClass([$props.customClass, "label"])
                  }, [
                    (_ctx.$slots.label)
                      ? vue.renderSlot(_ctx.$slots, "label", { key: 0 })
                      : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                          vue.createTextVNode(vue.toDisplayString($props.label), 1 /* TEXT */)
                        ], 64 /* STABLE_FRAGMENT */))
                  ], 10 /* CLASS, PROPS */, _hoisted_1$5))
                : vue.createCommentVNode("v-if", true)
            ], 2 /* CLASS */))
          : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
              ($options.hasLabel)
                ? (vue.openBlock(), vue.createElementBlock("label", {
                    key: 0,
                    for: $props.labelFor,
                    class: vue.normalizeClass([$props.customClass, "label"])
                  }, [
                    (_ctx.$slots.label)
                      ? vue.renderSlot(_ctx.$slots, "label", { key: 0 })
                      : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                          vue.createTextVNode(vue.toDisplayString($props.label), 1 /* TEXT */)
                        ], 64 /* STABLE_FRAGMENT */))
                  ], 10 /* CLASS, PROPS */, _hoisted_2$3))
                : vue.createCommentVNode("v-if", true)
            ], 64 /* STABLE_FRAGMENT */)),
        ($props.horizontal)
          ? (vue.openBlock(), vue.createBlock(_component_b_field_body, {
              key: 2,
              message: $data.newMessage ? $options.formattedMessage : '',
              type: $data.newType
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3 /* FORWARDED */
            }, 8 /* PROPS */, ["message", "type"]))
          : ($options.hasInnerField)
            ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$2, [
                vue.createVNode(_component_b_field, {
                  addons: false,
                  type: $props.type,
                  class: vue.normalizeClass($options.innerFieldClasses)
                }, {
                  default: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3 /* FORWARDED */
                }, 8 /* PROPS */, ["type", "class"])
              ]))
            : vue.renderSlot(_ctx.$slots, "default", { key: 4 }),
        ($options.hasMessage && !$props.horizontal)
          ? (vue.openBlock(), vue.createElementBlock("p", {
              key: 5,
              class: vue.normalizeClass(["help", $data.newType])
            }, [
              (_ctx.$slots.message)
                ? vue.renderSlot(_ctx.$slots, "message", {
                    key: 0,
                    messages: $options.formattedMessage
                  })
                : (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 1 }, vue.renderList($options.formattedMessage, (mess, i) => {
                    return (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
                      vue.createTextVNode(vue.toDisplayString(mess) + " ", 1 /* TEXT */),
                      ((i + 1) < $options.formattedMessage.length)
                        ? (vue.openBlock(), vue.createElementBlock("br", { key: i }))
                        : vue.createCommentVNode("v-if", true)
                    ], 64 /* STABLE_FRAGMENT */))
                  }), 256 /* UNKEYED_FRAGMENT */))
            ], 2 /* CLASS */))
          : vue.createCommentVNode("v-if", true)
      ], 2 /* CLASS */))
    }

    script$6.render = render$6;
    script$6.__file = "src/components/field/Field.vue";

    var script$5 = {
        name: 'BSelect',
        components: {
            [script$9.name]: script$9
        },
        mixins: [CompatFallthroughMixin, FormElementMixin],
        props: {
            modelValue: {
                type: [String, Number, Boolean, Object, Array, Function, Date],
                default: null
            },
            placeholder: String,
            multiple: Boolean,
            nativeSize: [String, Number]
        },
        emits: ['blur', 'focus', 'update:modelValue'],
        data() {
            return {
                selected: this.modelValue,
                _elementRef: 'select'
            }
        },
        computed: {
            computedValue: {
                get() {
                    return this.selected
                },
                set(value) {
                    this.selected = value;
                    this.$emit('update:modelValue', value);
                    !this.isValid && this.checkHtml5Validity();
                }
            },
            spanClasses() {
                return [this.size, this.statusType, {
                    'is-fullwidth': this.expanded,
                    'is-loading': this.loading,
                    'is-multiple': this.multiple,
                    'is-rounded': this.rounded,
                    'is-empty': this.selected === null
                }]
            }
        },
        watch: {
            /**
            * When v-model is changed:
            *   1. Set the selected option.
            *   2. If it's invalid, validate again.
            */
            modelValue(value) {
                this.selected = value;
                !this.isValid && this.checkHtml5Validity();
            }
        }
    };

    const _hoisted_1$4 = ["multiple", "size"];
    const _hoisted_2$2 = {
      key: 0,
      value: null,
      disabled: "",
      hidden: ""
    };

    function render$5(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_b_icon = vue.resolveComponent("b-icon");

      return (vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({
        class: ["control", { 'is-expanded': _ctx.expanded, 'has-icons-left': _ctx.icon }]
      }, _ctx.rootAttrs), [
        vue.createElementVNode("span", {
          class: vue.normalizeClass(["select", $options.spanClasses])
        }, [
          vue.withDirectives(vue.createElementVNode("select", vue.mergeProps({
            "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($options.computedValue) = $event)),
            ref: "select",
            multiple: $props.multiple,
            size: $props.nativeSize
          }, _ctx.fallthroughAttrs, {
            onBlur: _cache[1] || (_cache[1] = $event => (_ctx.$emit('blur', $event) && _ctx.checkHtml5Validity())),
            onFocus: _cache[2] || (_cache[2] = $event => (_ctx.$emit('focus', $event)))
          }), [
            ($props.placeholder)
              ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                  ($options.computedValue == null)
                    ? (vue.openBlock(), vue.createElementBlock("option", _hoisted_2$2, vue.toDisplayString($props.placeholder), 1 /* TEXT */))
                    : vue.createCommentVNode("v-if", true)
                ], 64 /* STABLE_FRAGMENT */))
              : vue.createCommentVNode("v-if", true),
            vue.renderSlot(_ctx.$slots, "default")
          ], 16 /* FULL_PROPS */, _hoisted_1$4), [
            [vue.vModelSelect, $options.computedValue]
          ])
        ], 2 /* CLASS */),
        (_ctx.icon)
          ? (vue.openBlock(), vue.createBlock(_component_b_icon, {
              key: 0,
              class: "is-left",
              icon: _ctx.icon,
              pack: _ctx.iconPack,
              size: _ctx.iconSize
            }, null, 8 /* PROPS */, ["icon", "pack", "size"]))
          : vue.createCommentVNode("v-if", true)
      ], 16 /* FULL_PROPS */))
    }

    script$5.render = render$5;
    script$5.__file = "src/components/select/Select.vue";

    const cos30 = 0.86602540378;
    const sin30 = 0.5;

    let id = 0;

    var script$4 = {
        name: 'BColorpickerHSLRepresentationTriangle',
        props: {
            value: {
                type: Object,
                required: true,
                validator(value) {
                    return typeof value.hue === 'number' &&
                        typeof value.saturation === 'number' &&
                        typeof value.lightness === 'number'
                }
            },
            size: {
                type: Number,
                default: 200
            },
            thickness: {
                type: Number,
                default: 20
            }
        },
        emits: ['input'],
        data() {
            return {
                id: id++,
                hue: this.value.hue,
                saturation: this.value.saturation,
                lightness: this.value.lightness,
                captureMouse: false,
                captureType: 'hue',
                clientOffset: {
                    cx: -1,
                    cy: -1,
                    width: 0,
                    height: 0
                },
                cos30,
                sin30,
                debounce: 0
            }
        },
        computed: {
            viewBox() {
                const { size } = this;
                return `0 0 ${size} ${size}`
            },
            internalRadius() {
                return this.size / 2 - this.thickness
            },
            haloPath() {
                const { size, thickness } = this;
                const radius = size / 2 - 2; // 2px padding
                const thicknessRadius = radius - thickness;
                const center = size / 2;

                return `M${center - radius} ${center}a${radius}  ${radius}  0 1 1 ${2 * radius} 0` +
                    `h${-thickness}` +
                    `a${-thicknessRadius}  ${thicknessRadius}  0 1 0 ${-2 * thicknessRadius} 0` +
                    `a${thicknessRadius}  ${thicknessRadius}  0 1 0 ${2 * thicknessRadius} 0` +
                    `h${thickness}` +
                    `a${radius}  ${radius}  0 1 1 ${-2 * radius} 0z`
            },
            trianglePath() {
                const { size, thickness } = this;
                const radius = size - 4;
                const thicknessRadius = (radius - 2 * thickness) / 2;

                return `M0 ${-thicknessRadius}` +
                    `L${cos30 * thicknessRadius} ${sin30 * thicknessRadius}` +
                    `H${-cos30 * thicknessRadius}z`
            }
        },
        watch: {
            captureMouse(newValue, oldValue) {
                if (oldValue === false && newValue !== false) {
                    const rect = this.$el.getBoundingClientRect();
                    // Caching offset
                    this.clientOffset.cx = rect.x + rect.width / 2;
                    this.clientOffset.cy = rect.y + rect.height / 2;
                    this.clientOffset.width = rect.width;
                    this.clientOffset.height = rect.height;
                }
            },
            value: {
                deep: true,
                handler(newColor) {
                    const { hue, saturation, lightness } = newColor;

                    window.clearTimeout(this.debounce);
                    this.debounce = window.setTimeout(() => {
                        if (lightness >= 0.03 && lightness <= 0.97 && saturation > 0) {
                            this.hue = hue;
                        }
                        this.saturation = saturation;
                        this.lightness = lightness;
                    }, 200);
                }
            }
        },
        methods: {
            increaseHue(value = 1) {
                this.hue = (this.hue + value) % 360;
            },
            decreaseHue(value = 1) {
                this.hue = (360 + this.hue - value) % 360;
            },
            increaseSaturation(value = 0.01) {
                this.saturation = Math.min(1, Math.max(0, this.saturation + value));
                this.lightness = Math.min(
                    0.5 + (1 - this.saturation) * 0.5,
                    Math.max(
                        0.5 - (1 - this.saturation) * 0.5,
                        this.lightness
                    )
                );
            },
            decreaseSaturation(value = 0.01) {
                this.saturation = Math.min(1, Math.max(0, this.saturation - value));
                this.lightness = Math.min(
                    0.5 + (1 - this.saturation) * 0.5,
                    Math.max(
                        0.5 - (1 - this.saturation) * 0.5,
                        this.lightness
                    )
                );
            },
            increaseLightness(value = 0.01) {
                this.lightness = Math.min(
                    0.5 + (1 - this.saturation) * 0.5,
                    Math.max(
                        0.5 - (1 - this.saturation) * 0.5,
                        this.lightness + value
                    )
                );
            },
            decreaseLightness(value = 0.01) {
                this.lightness = Math.min(
                    0.5 + (1 - this.saturation) * 0.5,
                    Math.max(
                        0.5 - (1 - this.saturation) * 0.5,
                        this.lightness - value
                    )
                );
            },
            hueKeyPress(event) {
                let handled = false;
                switch (event.key) {
                    case 'ArrowRight':
                    case 'ArrowUp':
                        this.increaseHue();
                        handled = true;
                        break
                    case 'ArrowLeft':
                    case 'ArrowDown':
                        this.decreaseHue();
                        handled = true;
                        break
                    case 'Home':
                        this.increaseHue(360 - this.hue);
                        handled = true;
                        break
                    case 'End':
                        this.decreaseHue(this.hue);
                        handled = true;
                        break
                    case 'PageUp':
                        this.increaseHue(60 - this.hue % 60);
                        handled = true;
                        break
                    case 'PageDown':
                        this.decreaseHue(60 + this.hue % 60);
                        handled = true;
                        break
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.emitColor();
                }
            },
            slKeyPress(event) {
                let handled = false;
                switch (event.key) {
                    case 'ArrowRight':
                        this.decreaseLightness();
                        handled = true;
                        break
                    case 'ArrowUp':
                        this.increaseSaturation();
                        handled = true;
                        break
                    case 'ArrowLeft':
                        this.increaseLightness();
                        handled = true;
                        break
                    case 'ArrowDown':
                        this.decreaseSaturation();
                        handled = true;
                        break
                    case 'Home':
                        this.increaseLightness(1 - this.lightness);
                        handled = true;
                        break
                    case 'End':
                        this.decreaseLightness(this.lightness);
                        handled = true;
                        break
                    case 'PageUp':
                        this.increaseSaturation(1 - this.saturation);
                        handled = true;
                        break
                    case 'PageDown':
                        this.decreaseSaturation(this.saturation);
                        handled = true;
                        break
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.emitColor();
                }
            },
            clickHue(event) {
                this.startMouseCapture(event);
                this.trackMouse(event);
                this.stopMouseCapture(event);
                this.$refs.hueCursor.focus();
            },
            clickSL(event) {
                this.startMouseCapture(event);
                this.trackMouse(event);
                this.stopMouseCapture(event);
                this.$refs.slCursor.focus();
            },
            trackMouse(event) {
                if (this.captureMouse === false) {
                    return
                }
                event.preventDefault();
                event.stopPropagation();

                let [mouseX, mouseY] = [0, 0];
                if (typeof event.touches !== 'undefined' && event.touches.length) {
                    [mouseX, mouseY] = [event.touches[0].clientX, event.touches[0].clientY];
                } else {
                    [mouseX, mouseY] = [event.clientX, event.clientY];
                }
                const angle = Math.atan2(
                    mouseY - this.clientOffset.cy,
                    mouseX - this.clientOffset.cx
                );

                if (this.captureType === 'sl') {
                    const d = Math.sqrt(
                        Math.pow(mouseX - this.clientOffset.cx, 2) +
                        Math.pow(mouseY - this.clientOffset.cy, 2)
                    );
                    const ratio = this.size / this.clientOffset.width;
                    const dx = d * Math.cos(angle - this.hue / 180 * Math.PI) * ratio;
                    const dy = d * Math.sin(angle - this.hue / 180 * Math.PI) * ratio;
                    const radius = this.internalRadius;
                    const saturation = 1 - (Math.min(
                        radius * sin30,
                        Math.max(
                            -radius,
                            dy
                        )
                    ) + radius) / (radius + radius * sin30);
                    const lightness = (Math.min(
                        (radius * cos30) * (1 - saturation),
                        Math.max(
                            (-radius * cos30) * (1 - saturation),
                            dx
                        )
                    ) + radius * cos30) / (radius * 2 * cos30);

                    this.saturation = Math.round(saturation * 1000) / 1000;
                    this.lightness = 1 - Math.round(lightness * 1000) / 1000;
                } else {
                    this.hue = Math.round(angle / Math.PI * 180 + 90) % 360;
                }
                this.emitColor();
            },
            startMouseCapture(event) {
                event.stopPropagation();

                this.captureMouse = true;
                if (event.target.closest('.colorpicker-triangle-slider-sl') !== null) {
                    this.captureType = 'sl';
                } else {
                    this.captureType = 'hue';
                }
            },
            stopMouseCapture(event) {
                if (this.captureMouse !== false) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus();
                }
                this.captureMouse = false;
            },
            emitColor() {
                const { hue, saturation, lightness } = this;
                this.$emit('input', Color$1.fromHSL(hue, saturation, lightness));
                window.clearTimeout(this.debounce);
            }
        },
        mounted() {
            window.addEventListener('mousemove', this.trackMouse);
            window.addEventListener('touchmove', this.trackMouse, { passive: false });
            window.addEventListener('mouseup', this.stopMouseCapture);
            window.addEventListener('touchend', this.stopMouseCapture);
        },
        beforeUnmount() {
            window.removeEventListener('mousemove', this.trackMouse);
            window.removeEventListener('touchmove', this.trackMouse);
            window.removeEventListener('mouseup', this.stopMouseCapture);
            window.removeEventListener('touchend', this.stopMouseCapture);

            clearTimeout(this.debounce);
        }
    };

    const _hoisted_1$3 = ["viewBox"];
    const _hoisted_2$1 = ["id"];
    const _hoisted_3$1 = /*#__PURE__*/vue.createElementVNode("stop", {
      offset: "0%",
      "stop-color": "#fff"
    }, null, -1 /* HOISTED */);
    const _hoisted_4$1 = /*#__PURE__*/vue.createElementVNode("stop", {
      offset: "100%",
      "stop-color": "#000"
    }, null, -1 /* HOISTED */);
    const _hoisted_5 = [
      _hoisted_3$1,
      _hoisted_4$1
    ];
    const _hoisted_6 = ["id"];
    const _hoisted_7 = ["stop-color"];
    const _hoisted_8 = ["stop-color"];
    const _hoisted_9 = ["id"];
    const _hoisted_10 = ["d"];
    const _hoisted_11 = { class: "colorpicker-triangle-slider-hue" };
    const _hoisted_12 = ["width", "height", "clip-path"];
    const _hoisted_13 = ["x", "height"];
    const _hoisted_14 = ["aria-valuenow"];
    const _hoisted_15 = ["d", "fill"];
    const _hoisted_16 = ["d", "fill"];
    const _hoisted_17 = ["x", "y"];
    const _hoisted_18 = ["aria-datavalues"];

    function render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return (vue.openBlock(), vue.createElementBlock("svg", {
        viewBox: $options.viewBox,
        class: "b-colorpicker-triangle"
      }, [
        vue.createElementVNode("defs", null, [
          vue.createElementVNode("linearGradient", {
            id: `cp-triangle-gradient-ligthness-${$data.id}`,
            x1: "0",
            y1: "0",
            x2: "1",
            y2: "0"
          }, [..._hoisted_5], 8 /* PROPS */, _hoisted_2$1),
          vue.createElementVNode("linearGradient", {
            id: `cp-triangle-gradient-saturation-${$data.id}`,
            x1: "0",
            y1: "0",
            x2: "0",
            y2: "1"
          }, [
            vue.createElementVNode("stop", {
              offset: "0%",
              "stop-color": `hsl(${$data.hue}deg, 100%, 50%)`,
              "stop-opacity": "1"
            }, null, 8 /* PROPS */, _hoisted_7),
            vue.createElementVNode("stop", {
              offset: "100%",
              "stop-color": `hsl(${$data.hue}deg, 100%, 50%)`,
              "stop-opacity": "0"
            }, null, 8 /* PROPS */, _hoisted_8)
          ], 8 /* PROPS */, _hoisted_6),
          vue.createElementVNode("clipPath", {
            id: `cp-triangle-clip-${$data.id}`
          }, [
            vue.createElementVNode("path", { d: $options.haloPath }, null, 8 /* PROPS */, _hoisted_10)
          ], 8 /* PROPS */, _hoisted_9)
        ]),
        vue.createElementVNode("g", _hoisted_11, [
          (vue.openBlock(), vue.createElementBlock("foreignObject", {
            x: 0,
            y: 0,
            width: $props.size,
            height: $props.size,
            "clip-path": `url(#cp-triangle-clip-${$data.id})`
          }, [
            vue.createElementVNode("div", {
              class: "colorpicker-triangle-hue",
              onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickHue && $options.clickHue(...args))),
              onMousedown: _cache[1] || (_cache[1] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
              onTouchstart: _cache[2] || (_cache[2] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
            }, null, 32 /* HYDRATE_EVENTS */)
          ], 8 /* PROPS */, _hoisted_12)),
          vue.createElementVNode("g", {
            style: vue.normalizeStyle(`transform: rotate(${$data.hue}deg)`)
          }, [
            (vue.openBlock(), vue.createElementBlock("foreignObject", {
              x: $props.size / 2 - 4,
              y: 0,
              width: "8",
              height: $props.thickness + 4
            }, [
              vue.createElementVNode("div", {
                ref: "hueCursor",
                class: "hue-range-thumb",
                style: vue.normalizeStyle(`background-color: hsl(${$data.hue}deg, 100%, 50%)`),
                role: "slider",
                tabindex: "0",
                "aria-label": "Hue",
                "aria-valuemin": "0",
                "aria-valuenow": $data.hue,
                "aria-valuemax": "360",
                onClick: _cache[3] || (_cache[3] = (...args) => ($options.clickHue && $options.clickHue(...args))),
                onKeydown: _cache[4] || (_cache[4] = (...args) => ($options.hueKeyPress && $options.hueKeyPress(...args))),
                onMousedown: _cache[5] || (_cache[5] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
                onTouchstart: _cache[6] || (_cache[6] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
              }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_14)
            ], 8 /* PROPS */, _hoisted_13))
          ], 4 /* STYLE */)
        ]),
        vue.createElementVNode("g", {
          class: "colorpicker-triangle-slider-sl",
          style: vue.normalizeStyle(`transform: rotate(${$data.hue}deg) translate(50%, 50%)`),
          role: "graphics-datagroup",
          "aria-datascales": "lightness, saturation"
        }, [
          vue.createElementVNode("path", {
            d: $options.trianglePath,
            fill: `url(#cp-triangle-gradient-ligthness-${$data.id})`
          }, null, 8 /* PROPS */, _hoisted_15),
          vue.createElementVNode("path", {
            d: $options.trianglePath,
            fill: `url(#cp-triangle-gradient-saturation-${$data.id})`,
            style: {"mix-blend-mode":"overlay"},
            onClick: _cache[7] || (_cache[7] = (...args) => ($options.clickSL && $options.clickSL(...args))),
            onMousedown: _cache[8] || (_cache[8] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
            onTouchstart: _cache[9] || (_cache[9] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
          }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_16),
          (vue.openBlock(), vue.createElementBlock("foreignObject", {
            x: (($options.internalRadius - 3) * $data.cos30) * (-$data.lightness + 0.5) * 2 - 6,
            y: -$options.internalRadius + (1 - $data.saturation) * ($options.internalRadius - 3) * 1.5 - 3,
            width: "12",
            height: "12"
          }, [
            vue.createElementVNode("div", {
              ref: "slCursor",
              class: "sl-range-thumb",
              style: vue.normalizeStyle({
                            backgroundColor: `hsl(${$data.hue}deg, ${$data.saturation * 100}%, ${$data.lightness * 100}%)`
                        }),
              tabindex: "0",
              "aria-datavalues": `${$data.saturation * 100}%, ${$data.lightness * 100}%`,
              onClick: _cache[10] || (_cache[10] = (...args) => ($options.clickSL && $options.clickSL(...args))),
              onKeydown: _cache[11] || (_cache[11] = (...args) => ($options.slKeyPress && $options.slKeyPress(...args))),
              onMousedown: _cache[12] || (_cache[12] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
              onTouchstart: _cache[13] || (_cache[13] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
            }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_18)
          ], 8 /* PROPS */, _hoisted_17))
        ], 4 /* STYLE */)
      ], 8 /* PROPS */, _hoisted_1$3))
    }

    script$4.render = render$4;
    script$4.__file = "src/components/colorpicker/ColorpickerHSLRepresentationTriangle.vue";

    const precision = (strs, ...values) => {
        const tmp = [];
        strs.forEach((str, i) => {
            tmp.push(str);

            if (values[i]) {
                tmp.push(
                    Number.isNaN(values[i] / 1)
                        ? values[i]
                        : Math.round(values * 10) / 10
                );
            }
        });

        return tmp.join('')
    };

    var script$3 = {
        name: 'BColorpickerHSLRepresentationSquare',
        props: {
            value: {
                type: Object,
                required: true,
                validator(value) {
                    return typeof value.hue === 'number' &&
                        typeof value.saturation === 'number' &&
                        typeof value.lightness === 'number'
                }
            },
            size: {
                type: Number,
                default: 200
            },
            thickness: {
                type: Number,
                default: 20
            }
        },
        emits: ['input'],
        data() {
            return {
                hue: this.value.hue,
                saturation: this.value.saturation,
                lightness: this.value.lightness,
                captureMouse: false,
                captureType: 'hue',
                clientOffset: {
                    cx: -1,
                    cy: -1,
                    width: 0,
                    height: 0
                },
                debounce: 0
            }
        },
        computed: {
            hueThumbStyle() {
                const { hue, size, thickness } = this;
                const side = size - thickness;
                const offset = size / 2;
                const angle = ((hue + 720 + 90) % 360) / 180 * Math.PI;
                const ciq = 1 / Math.cos(Math.PI / 4);
                const { x, y } = {
                    x: -Math.min(1, Math.max(-1, ciq * Math.cos(angle))) / 2 * side + offset,
                    y: -Math.min(1, Math.max(-1, ciq * Math.sin(angle))) / 2 * side + offset
                };
                return {
                    background: `hsl(${hue}deg, 100%, 50%)`,
                    left: precision`${x}px`,
                    top: precision`${y}px`,
                    width: precision`${thickness - 2}px`
                }
            },
            slThumbStyle() {
                let { hue, saturation, lightness } = this;
                saturation = Math.max(0, Math.min(1, saturation));
                lightness = Math.max(0, Math.min(1, lightness));
                return {
                    background: `hsl(${hue}deg, ${saturation * 100}%, ${lightness * 100}%)`,
                    left: `${saturation * 100}%`,
                    top: `${(1 - lightness) * 100}%`
                }
            },
            SLBackground() {
                const { hue } = this;
                return `linear-gradient(90deg, hsl(${hue}deg, 0%, 50%), hsl(${hue}deg, 100%, 50%))`
            }
        },
        watch: {
            captureMouse(newValue, oldValue) {
                if (oldValue === false && newValue !== false) {
                    const rect = this.$el.getBoundingClientRect();
                    // Caching offset
                    this.clientOffset.cx = rect.x + rect.width / 2;
                    this.clientOffset.cy = rect.y + rect.height / 2;
                    this.clientOffset.width = rect.width;
                    this.clientOffset.height = rect.height;
                }
            },
            value: {
                deep: true,
                handler(newColor) {
                    const { hue, saturation, lightness } = newColor;

                    window.clearTimeout(this.debounce);
                    this.debounce = window.setTimeout(() => {
                        this.hue = hue;
                        this.saturation = saturation;
                        this.lightness = lightness;
                    }, 200);
                }
            }
        },
        methods: {
            increaseHue(value = 1) {
                this.hue = (this.hue + value) % 360;
            },
            decreaseHue(value = 1) {
                this.hue = (360 + this.hue - value) % 360;
            },
            increaseSaturation(value = 0.01) {
                this.saturation = Math.min(1, Math.max(0, this.saturation + value));
                this.lightness = Math.min(
                    0.5 + (1 - this.saturation) * 0.5,
                    Math.max(
                        0.5 - (1 - this.saturation) * 0.5,
                        this.lightness
                    )
                );
            },
            decreaseSaturation(value = 0.01) {
                this.saturation = Math.min(1, Math.max(0, this.saturation - value));
                this.lightness = Math.min(
                    0.5 + (1 - this.saturation) * 0.5,
                    Math.max(
                        0.5 - (1 - this.saturation) * 0.5,
                        this.lightness
                    )
                );
            },
            increaseLightness(value = 0.01) {
                this.lightness = Math.min(
                    0.5 + (1 - this.saturation) * 0.5,
                    Math.max(
                        0.5 - (1 - this.saturation) * 0.5,
                        this.lightness + value
                    )
                );
            },
            decreaseLightness(value = 0.01) {
                this.lightness = Math.min(
                    0.5 + (1 - this.saturation) * 0.5,
                    Math.max(
                        0.5 - (1 - this.saturation) * 0.5,
                        this.lightness - value
                    )
                );
            },
            hueKeyPress(event) {
                let handled = false;
                switch (event.key) {
                    case 'ArrowRight':
                    case 'ArrowUp':
                        this.increaseHue();
                        handled = true;
                        break
                    case 'ArrowLeft':
                    case 'ArrowDown':
                        this.decreaseHue();
                        handled = true;
                        break
                    case 'Home':
                        this.increaseHue(360 - this.hue);
                        handled = true;
                        break
                    case 'End':
                        this.decreaseHue(this.hue);
                        handled = true;
                        break
                    case 'PageUp':
                        this.increaseHue(60 - this.hue % 60);
                        handled = true;
                        break
                    case 'PageDown':
                        this.decreaseHue(60 + this.hue % 60);
                        handled = true;
                        break
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.emitColor();
                }
            },
            slKeyPress(event) {
                let handled = false;
                switch (event.key) {
                    case 'ArrowRight':
                        this.increaseSaturation();
                        handled = true;
                        break
                    case 'ArrowUp':
                        this.increaseLightness();
                        handled = true;
                        break
                    case 'ArrowLeft':
                        this.decreaseSaturation();
                        handled = true;
                        break
                    case 'ArrowDown':
                        this.decreaseLightness();
                        handled = true;
                        break
                    case 'Home':
                        this.increaseLightness(1 - this.lightness);
                        handled = true;
                        break
                    case 'End':
                        this.decreaseLightness(this.lightness);
                        handled = true;
                        break
                    case 'PageUp':
                        this.increaseSaturation(1 - this.saturation);
                        handled = true;
                        break
                    case 'PageDown':
                        this.decreaseSaturation(this.saturation);
                        handled = true;
                        break
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.emitColor();
                }
            },
            startMouseCapture(event) {
                event.stopPropagation();

                this.captureMouse = true;
                if (event.target.closest('.colorpicker-square-slider-sl') !== null) {
                    this.captureType = 'sl';
                } else {
                    this.captureType = 'hue';
                }
            },
            stopMouseCapture(event) {
                if (this.captureMouse !== false) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.$refs[this.captureType === 'sl' ? 'slCursor' : 'hueCursor'].focus();
                }
                this.captureMouse = false;
            },
            clickHue(event) {
                this.startMouseCapture(event);
                this.trackMouse(event);
                this.stopMouseCapture(event);
                this.$refs.hueCursor.focus();
            },
            clickSL(event) {
                this.startMouseCapture(event);
                this.trackMouse(event);
                this.stopMouseCapture(event);
                this.$refs.slCursor.focus();
            },
            trackMouse(event) {
                if (this.captureMouse === false) {
                    return
                }
                event.preventDefault();
                event.stopPropagation();

                let [mouseX, mouseY] = [0, 0];
                if (typeof event.touches !== 'undefined' && event.touches.length) {
                    [mouseX, mouseY] = [event.touches[0].clientX, event.touches[0].clientY];
                } else {
                    [mouseX, mouseY] = [event.clientX, event.clientY];
                }
                const angle = Math.atan2(
                    mouseY - this.clientOffset.cy,
                    mouseX - this.clientOffset.cx
                );

                if (this.captureType === 'sl') {
                    const saturation = (mouseX - this.clientOffset.cx) /
                        (this.clientOffset.width - this.thickness * 2) +
                        0.5;
                    const lightness = (mouseY - this.clientOffset.cy) /
                        (this.clientOffset.height - this.thickness * 2) +
                        0.5;

                    this.saturation = Math.round(Math.min(1, Math.max(0, saturation)) * 1000) / 1000;
                    this.lightness = 1 - Math.round(Math.min(1, Math.max(0, lightness)) * 1000) / 1000;
                } else {
                    this.hue = Math.round(angle / Math.PI * 180 + 90) % 360;
                }
                this.emitColor();
            },
            emitColor() {
                const { hue, saturation, lightness } = this;
                this.$emit('input', Color$1.fromHSL(hue, saturation, lightness));
                window.clearTimeout(this.debounce);
            }
        },
        mounted() {
            window.addEventListener('mousemove', this.trackMouse);
            window.addEventListener('touchmove', this.trackMouse, { passive: false });
            window.addEventListener('mouseup', this.stopMouseCapture);
            window.addEventListener('touchend', this.stopMouseCapture);
        },
        beforeUnmount() {
            window.removeEventListener('mousemove', this.trackMouse);
            window.removeEventListener('touchmove', this.trackMouse);
            window.removeEventListener('mouseup', this.stopMouseCapture);
            window.removeEventListener('touchend', this.stopMouseCapture);

            clearTimeout(this.debounce);
        }
    };

    const _hoisted_1$2 = ["aria-datavalues"];

    function render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return (vue.openBlock(), vue.createElementBlock("div", {
        class: "b-colorpicker-square",
        style: vue.normalizeStyle({ width: `${$props.size}px` })
      }, [
        vue.createElementVNode("div", {
          class: "colorpicker-square-slider-hue",
          onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickHue && $options.clickHue(...args))),
          onMousedown: _cache[1] || (_cache[1] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
          onTouchstart: _cache[2] || (_cache[2] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
        }, [
          vue.createElementVNode("div", {
            ref: "hueCursor",
            role: "slider",
            class: "hue-range-thumb",
            tabindex: "0",
            "aria-label": "Hue",
            "aria-valuemin": "0",
            "aria-valuemax": "359",
            style: vue.normalizeStyle($options.hueThumbStyle)
          }, null, 4 /* STYLE */)
        ], 32 /* HYDRATE_EVENTS */),
        vue.createElementVNode("div", {
          class: "colorpicker-square-slider-sl",
          style: vue.normalizeStyle({
                    background: $options.SLBackground,
                    margin: `${$props.thickness}px`
                }),
          "aria-datascales": "lightness, saturation",
          onClick: _cache[7] || (_cache[7] = (...args) => ($options.clickSL && $options.clickSL(...args))),
          onMousedown: _cache[8] || (_cache[8] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
          onTouchstart: _cache[9] || (_cache[9] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
        }, [
          vue.createElementVNode("div", {
            ref: "slCursor",
            role: "slider",
            class: "sl-range-thumb",
            tabindex: "0",
            "aria-datavalues": `${$data.saturation * 100}%, ${$data.lightness * 100}%`,
            style: vue.normalizeStyle($options.slThumbStyle),
            onClick: _cache[3] || (_cache[3] = (...args) => ($options.clickSL && $options.clickSL(...args))),
            onKeydown: _cache[4] || (_cache[4] = (...args) => ($options.slKeyPress && $options.slKeyPress(...args))),
            onMousedown: _cache[5] || (_cache[5] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"])),
            onTouchstart: _cache[6] || (_cache[6] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
          }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, _hoisted_1$2)
        ], 36 /* STYLE, HYDRATE_EVENTS */)
      ], 4 /* STYLE */))
    }

    script$3.render = render$3;
    script$3.__file = "src/components/colorpicker/ColorpickerHSLRepresentationSquare.vue";

    var script$2 = {
        name: 'BTooltip',
        props: {
            active: {
                type: Boolean,
                default: true
            },
            type: {
                type: String,
                default: () => config.defaultTooltipType
            },
            label: String,
            delay: {
                type: Number,
                default: () => config.defaultTooltipDelay
            },
            closeDelay: {
                type: Number,
                default: () => config.defaultTooltipCloseDelay
            },
            position: {
                type: String,
                default: 'is-top',
                validator(value) {
                    return [
                        'is-top',
                        'is-bottom',
                        'is-left',
                        'is-right'
                    ].indexOf(value) > -1
                }
            },
            triggers: {
                type: Array,
                default: () => ['hover']
            },
            always: Boolean,
            square: Boolean,
            dashed: Boolean,
            multilined: Boolean,
            size: {
                type: String,
                default: 'is-medium'
            },
            appendToBody: Boolean,
            animated: {
                type: Boolean,
                default: true
            },
            animation: {
                type: String,
                default: 'fade'
            },
            contentClass: String,
            autoClose: {
                type: [Array, Boolean],
                default: true
            }
        },
        emits: ['close', 'open'],
        data() {
            return {
                isActive: false,
                triggerStyle: {},
                timer: null,
                _bodyEl: undefined, // Used to append to body
                resizeObserver: undefined,
                resizeListener: undefined,
                timeOutID: null
            }
        },
        computed: {
            rootClasses() {
                return ['b-tooltip', this.type, this.position, this.size, {
                    'is-square': this.square,
                    'is-always': this.always,
                    'is-multiline': this.multilined,
                    'is-dashed': this.dashed
                }]
            },
            newAnimation() {
                return this.animated ? this.animation : undefined
            }
        },
        watch: {
            isActive() {
                this.$emit(this.isActive ? 'open' : 'close');
                if (this.appendToBody) {
                    this.updateAppendToBody();
                }
            }
        },
        methods: {
            updateAppendToBody() {
                const tooltip = this.$refs.tooltip;
                const trigger = this.$refs.trigger;
                if (tooltip && trigger) {
                    // update wrapper tooltip
                    const tooltipEl = this.$data._bodyEl.children[0];
                    tooltipEl.classList.forEach((item) => tooltipEl.classList.remove(item));
                    if (
                        this.$vnode &&
                        this.$vnode.data &&
                        this.$vnode.data.staticClass
                    ) {
                        tooltipEl.classList.add(this.$vnode.data.staticClass);
                    }
                    this.rootClasses.forEach((item) => {
                        if (typeof item === 'object') {
                            for (const key in item) {
                                if (item[key]) {
                                    tooltipEl.classList.add(key);
                                }
                            }
                        } else {
                            tooltipEl.classList.add(item);
                        }
                    });

                    const rect = trigger.getBoundingClientRect();

                    const top = rect.top + window.scrollY;
                    const left = rect.left + window.scrollX;

                    // `tooltipEl` will be placed relative to `wrapper`
                    // because `wrapper` should create a stacking context
                    // as its z-index is non-auto
                    tooltipEl.style.position = 'absolute';
                    switch (this.position) {
                        case 'is-top':
                            tooltipEl.style.width = `${trigger.clientWidth}px`;
                            tooltipEl.style.height = '0px';
                            tooltipEl.style.top = '0px';
                            tooltipEl.style.left = '0px';
                            break
                        case 'is-bottom':
                            tooltipEl.style.width = `${trigger.clientWidth}px`;
                            tooltipEl.style.height = '0px';
                            tooltipEl.style.top = `${trigger.clientHeight}px`;
                            tooltipEl.style.left = '0px';
                            break
                        case 'is-left':
                            tooltipEl.style.width = '0px';
                            tooltipEl.style.height = `${trigger.clientHeight}px`;
                            tooltipEl.style.top = '0px';
                            tooltipEl.style.left = '0px';
                            break
                        case 'is-right':
                            tooltipEl.style.width = '0px';
                            tooltipEl.style.height = `${trigger.clientHeight}px`;
                            tooltipEl.style.top = '0px';
                            tooltipEl.style.left = `${trigger.clientWidth}px`;
                            break
                    }

                    const wrapper = this.$data._bodyEl;
                    wrapper.style.position = 'absolute';
                    wrapper.style.top = `${top}px`;
                    wrapper.style.left = `${left}px`;
                    wrapper.style.width = '0px';
                    wrapper.style.zIndex = this.isActive || this.always ? '99' : '-1';
                    this.triggerStyle = {
                        zIndex: this.isActive || this.always ? '100' : undefined
                    };
                }
            },
            onClick() {
                if (this.triggers.indexOf('click') < 0) return
                // if not active, toggle after clickOutside event
                // this fixes toggling programmatic
                this.$nextTick(() => {
                    this.timeOutID = setTimeout(() => this.open());
                });
            },
            onHover() {
                if (this.triggers.indexOf('hover') < 0) return
                this.open();
            },
            onContextMenu(e) {
                if (this.triggers.indexOf('contextmenu') < 0) return
                e.preventDefault();
                this.open();
            },
            onFocus() {
                if (this.triggers.indexOf('focus') < 0) return
                this.open();
            },
            open() {
                if (this.delay) {
                    this.timer = setTimeout(() => {
                        this.isActive = true;
                        this.timer = null;
                    }, this.delay);
                } else {
                    this.isActive = true;
                }
            },
            close() {
                if (typeof this.autoClose === 'boolean') {
                    if (this.autoClose && this.timer) clearTimeout(this.timer);
                    if (this.closeDelay) {
                        this.timer = setTimeout(() => {
                            this.isActive = !this.autoClose;
                            this.timer = null;
                        }, this.closeDelay);
                    } else {
                        this.isActive = !this.autoClose;
                    }
                }
            },
            /**
            * Close tooltip if clicked outside.
            */
            clickedOutside(event) {
                if (this.isActive) {
                    if (Array.isArray(this.autoClose)) {
                        if (this.autoClose.includes('outside')) {
                            if (!this.isInWhiteList(event.target)) {
                                this.isActive = false;
                                return
                            }
                        }
                        if (this.autoClose.includes('inside')) {
                            if (this.isInWhiteList(event.target)) this.isActive = false;
                        }
                    }
                }
            },
            /**
             * Keypress event that is bound to the document
             */
            keyPress({ key }) {
                if (this.isActive && (key === 'Escape' || key === 'Esc')) {
                    if (Array.isArray(this.autoClose)) {
                        if (this.autoClose.indexOf('escape') >= 0) this.isActive = false;
                    }
                }
            },
            /**
            * White-listed items to not close when clicked.
            */
            isInWhiteList(el) {
                if (el === this.$refs.content) return true
                // All chidren from content
                if (this.$refs.content != null) {
                    const children = this.$refs.content.querySelectorAll('*');
                    for (const child of children) {
                        if (el === child) {
                            return true
                        }
                    }
                }
                return false
            }
        },
        mounted() {
            if (this.appendToBody && typeof window !== 'undefined') {
                this.controller = new window.AbortController();
                this.$data._bodyEl = createAbsoluteElement(this.$refs.content);
                this.updateAppendToBody();
                // updates the tooltip position if the tooltip is inside
                // `.animation-content`
                const animation = this.$el.closest('.animation-content');
                if (animation != null) {
                    const listener = () => {
                        this.updateAppendToBody();
                        animation.removeEventListener('transitionend', listener);
                    };
                    animation.addEventListener('transitionend', listener, {
                        signal: this.controller.signal
                    });
                }
                // observes changes in the window size
                this.resizeListener = () => this.updateAppendToBody();
                window.addEventListener('resize', this.resizeListener);
                // observes changes in the size of the immediate parent
                this.resizeObserver = new ResizeObserver(this.resizeListener);
                if (this.$el.parentNode != null && this.$el.parentNode.nodeType === Node.ELEMENT_NODE) {
                    this.resizeObserver.observe(this.$el.parentNode);
                }
            }
        },
        created() {
            if (typeof window !== 'undefined') {
                document.addEventListener('click', this.clickedOutside);
                document.addEventListener('keyup', this.keyPress);
            }
        },
        beforeUnmount() {
            if (typeof window !== 'undefined') {
                document.removeEventListener('click', this.clickedOutside);
                document.removeEventListener('keyup', this.keyPress);
            }
            if (this.resizeListener != null) {
                window.removeEventListener('resize', this.resizeListener);
            }
            if (this.resizeObserver != null) {
                this.resizeObserver.disconnect();
            }
            if (this.appendToBody) {
                removeElement(this.$data._bodyEl);
            }
            if (this.controller != null) {
                this.controller.abort();
            }
            clearTimeout(this.timer);
            clearTimeout(this.timeOutID);
        }
    };

    function render$2(_ctx, _cache, $props, $setup, $data, $options) {
      return (vue.openBlock(), vue.createElementBlock("div", {
        ref: "tooltip",
        class: vue.normalizeClass($options.rootClasses)
      }, [
        vue.createVNode(vue.Transition, {
          name: $options.newAnimation,
          persisted: ""
        }, {
          default: vue.withCtx(() => [
            vue.withDirectives(vue.createElementVNode("div", {
              ref: "content",
              class: vue.normalizeClass(['tooltip-content', $props.contentClass])
            }, [
              ($props.label)
                ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                    vue.createTextVNode(vue.toDisplayString($props.label), 1 /* TEXT */)
                  ], 64 /* STABLE_FRAGMENT */))
                : (_ctx.$slots.content)
                  ? vue.renderSlot(_ctx.$slots, "content", { key: 1 })
                  : vue.createCommentVNode("v-if", true)
            ], 2 /* CLASS */), [
              [vue.vShow, $props.active && ($data.isActive || $props.always)]
            ])
          ]),
          _: 3 /* FORWARDED */
        }, 8 /* PROPS */, ["name"]),
        vue.createElementVNode("div", {
          ref: "trigger",
          class: "tooltip-trigger",
          style: vue.normalizeStyle($data.triggerStyle),
          onClick: _cache[0] || (_cache[0] = (...args) => ($options.onClick && $options.onClick(...args))),
          onContextmenu: _cache[1] || (_cache[1] = (...args) => ($options.onContextMenu && $options.onContextMenu(...args))),
          onMouseenter: _cache[2] || (_cache[2] = (...args) => ($options.onHover && $options.onHover(...args))),
          onFocusCapture: _cache[3] || (_cache[3] = (...args) => ($options.onFocus && $options.onFocus(...args))),
          onBlurCapture: _cache[4] || (_cache[4] = (...args) => ($options.close && $options.close(...args))),
          onMouseleave: _cache[5] || (_cache[5] = (...args) => ($options.close && $options.close(...args)))
        }, [
          vue.renderSlot(_ctx.$slots, "default", { ref: "slot" })
        ], 36 /* STYLE, HYDRATE_EVENTS */)
      ], 2 /* CLASS */))
    }

    script$2.render = render$2;
    script$2.__file = "src/components/tooltip/Tooltip.vue";

    var script$1 = {
        name: 'BColorpickerAlphaSlider',
        components: {
            [script$2.name]: script$2
        },
        props: {
            value: {
                type: Number,
                validator: (value) => value >= 0 && value < 256
            },
            color: [String, Object]
        },
        emits: ['input'],
        data() {
            const color = Color$1.parse(this.color);

            color.alpha = 0;
            return {
                startColor: color.toString('hex'),
                endColor: color.toString('hexa'),
                percent: Math.round((1 - this.value / 255) * 100),
                captureMouse: false,
                clientOffset: {
                    cx: -1,
                    cy: -1,
                    width: 0,
                    height: 0
                }
            }
        },
        computed: {
            style() {
                return {
                    backgroundImage:
                        `linear-gradient(90deg, ${this.startColor} 0%, ${this.endColor} 100%),
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)`,
                    backgroundSize: '100% 100%, 1em 1em, 1em 1em',
                    backgroundPosition: '0 0, .5em .5em, 0 0'
                }
            }
        },
        watch: {
            value(newValue, oldValue) {
                if (newValue !== oldValue) {
                    this.percent = Math.round((1 - newValue / 255) * 100);
                }
            },
            color(newColor) {
                const color = Color$1.parse(newColor);

                color.alpha = 0;
                this.startColor = color.toString('hex');
                this.endColor = color.toString('hexa');
            },
            captureMouse(newValue, oldValue) {
                if (oldValue === false && newValue !== false) {
                    const rect = this.$el.getBoundingClientRect();
                    // Caching offset
                    this.clientOffset.cx = rect.x + rect.width / 2;
                    this.clientOffset.cy = rect.y + rect.height / 2;
                    this.clientOffset.width = rect.width;
                    this.clientOffset.height = rect.height;
                }
            }
        },
        methods: {
            increaseAlpha(value = 1) {
                this.percent = Math.max(0, Math.min(100, this.percent + value));
            },
            decreaseAlpha(value = 0.01) {
                this.increaseAlpha(-value);
            },
            alphaKeyPress(event) {
                let handled = false;
                switch (event.key) {
                    case 'ArrowRight':
                    case 'ArrowUp':
                        this.increaseAlpha();
                        handled = true;
                        break
                    case 'ArrowLeft':
                    case 'ArrowDown':
                        this.decreaseAlpha();
                        handled = true;
                        break
                    case 'Home':
                        this.decreaseAlpha(this.percent);
                        handled = true;
                        break
                    case 'End':
                        this.increaseAlpha(100 - this.percent);
                        handled = true;
                        break
                    case 'PageUp':
                        this.increaseAlpha(10 - (this.percent % 10));
                        handled = true;
                        break
                    case 'PageDown':
                        this.decreaseAlpha(this.percent % 10);
                        handled = true;
                        break
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.emitAlpha();
                }
            },
            clickAlpha(event) {
                this.startMouseCapture(event);
                this.trackMouse(event);
                this.stopMouseCapture(event);
                this.$refs.alphaCursor.focus();
            },
            startMouseCapture(event) {
                event.stopPropagation();

                this.captureMouse = true;
            },
            trackMouse(event) {
                if (this.captureMouse === false) {
                    return
                }
                event.preventDefault();
                event.stopPropagation();

                let [mouseX] = [0, 0];
                if (typeof event.touches !== 'undefined' && event.touches.length) {
                    [mouseX] = [event.touches[0].clientX];
                } else {
                    [mouseX] = [event.clientX];
                }

                const ratio = 0.5 + (this.clientOffset.cx - mouseX) / this.clientOffset.width;
                this.percent = Math.round(100 - Math.max(0, Math.min(1, ratio)) * 100);
                this.emitAlpha();
            },
            stopMouseCapture(event) {
                if (this.captureMouse !== false) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.$refs.alphaCursor.focus();
                }
                this.captureMouse = false;
            },
            emitAlpha() {
                this.$emit('input', (1 - this.percent / 100) * 255);
            }
        },
        mounted() {
            window.addEventListener('mousemove', this.trackMouse);
            window.addEventListener('touchmove', this.trackMouse, { passive: false });
            window.addEventListener('mouseup', this.stopMouseCapture);
            window.addEventListener('touchend', this.stopMouseCapture);
        },
        beforeUnmount() {
            window.removeEventListener('mousemove', this.trackMouse);
            window.removeEventListener('touchmove', this.trackMouse);
            window.removeEventListener('mouseup', this.stopMouseCapture);
            window.removeEventListener('touchend', this.stopMouseCapture);
        }
    };

    const _hoisted_1$1 = ["aria-valuenow"];

    function render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_b_tooltip = vue.resolveComponent("b-tooltip");

      return (vue.openBlock(), vue.createElementBlock("div", {
        class: "b-colorpicker-alpha-slider",
        style: vue.normalizeStyle($options.style),
        onClick: _cache[0] || (_cache[0] = (...args) => ($options.clickAlpha && $options.clickAlpha(...args))),
        onKeydown: _cache[1] || (_cache[1] = (...args) => ($options.alphaKeyPress && $options.alphaKeyPress(...args))),
        onMousedown: _cache[2] || (_cache[2] = (...args) => ($options.startMouseCapture && $options.startMouseCapture(...args))),
        onTouchstart: _cache[3] || (_cache[3] = vue.withModifiers((...args) => ($options.startMouseCapture && $options.startMouseCapture(...args)), ["prevent"]))
      }, [
        vue.createElementVNode("div", {
          ref: "alphaCursor",
          role: "slider",
          class: "alpha-range-thumb",
          tabindex: "0",
          "aria-label": "Tranparency",
          "aria-valuemin": "0",
          "aria-valuenow": $data.percent,
          "aria-valuemax": "100",
          style: vue.normalizeStyle({ left: `${$data.percent}%` })
        }, [
          vue.createVNode(_component_b_tooltip, {
            label: `${$data.percent}%`,
            always: $data.captureMouse
          }, {
            default: vue.withCtx(() => [
              vue.createTextVNode("  ")
            ]),
            _: 1 /* STABLE */
          }, 8 /* PROPS */, ["label", "always"])
        ], 12 /* STYLE, PROPS */, _hoisted_1$1)
      ], 36 /* STYLE, HYDRATE_EVENTS */))
    }

    script$1.render = render$1;
    script$1.__file = "src/components/colorpicker/ColorpickerAlphaSlider.vue";

    const defaultColorFormatter = (color, vm) => {
        if (color.alpha < 1) {
            return color.toString('hexa')
        } else {
            return color.toString('hex')
        }
    };

    const defaultColorParser = (color, vm) => {
        return Color$1.parse(color)
    };

    var script = {
        name: 'BColorpicker',
        components: {
            [script$4.name]: script$4,
            [script$3.name]: script$3,
            [script$1.name]: script$1,
            [script$8.name]: script$8,
            [script$6.name]: script$6,
            [script$5.name]: script$5,
            [script$9.name]: script$9,
            [script$b.name]: script$b,
            [script$a.name]: script$a
        },
        mixins: [FormElementMixin],
        inheritAttrs: false,
        provide() {
            return {
                $colorpicker: this
            }
        },
        props: {
            modelValue: {
                type: [String, Object],
                validator(value) {
                    return typeof value === 'string' ||
                        (
                            typeof value === 'object' &&
                            typeof value.red === 'number' &&
                            typeof value.green === 'number' &&
                            typeof value.blue === 'number'
                        )
                }
            },
            representation: {
                type: String,
                default: 'triangle',
                value(value) {
                    return ['triangle', 'square'].some((r) => r === value)
                }
            },
            inline: Boolean,
            disabled: Boolean,
            horizontalColorPicker: {
                type: Boolean,
                default: false
            },
            colorFormatter: {
                type: Function,
                default: (color, vm) => {
                    if (typeof config.defaultColorFormatter === 'function') {
                        return config.defaultColorFormatter(color)
                    } else {
                        return defaultColorFormatter(color)
                    }
                }
            },
            colorParser: {
                type: Function,
                default: (color, vm) => {
                    if (typeof config.defaultColorParser === 'function') {
                        return config.defaultColorParser(color)
                    } else {
                        return defaultColorParser(color)
                    }
                }
            },
            alpha: {
                type: Boolean,
                default: false
            },
            expanded: Boolean,
            position: String,
            mobileModal: {
                type: Boolean,
                default: () => config.defaultDatepickerMobileModal
            },
            focusable: {
                type: Boolean,
                default: true
            },
            trapFocus: {
                type: Boolean,
                default: () => config.defaultTrapFocus
            },
            appendToBody: Boolean
        },
        emits: ['active-change', 'update:modelValue'],
        data() {
            return {
                color: this.parseColor(this.modelValue)
            }
        },
        computed: {
            computedValue: {
                set(value) {
                    this.color = this.parseColor(value);
                },
                get() {
                    return this.color
                }
            },
            background() {
                if (this.alpha) {
                    return `linear-gradient(
                    45deg,
                    ${this.computedValue.toString('hex')} 50%,
                    ${this.computedValue.toString('hexa')} 50%
                )`
                } else {
                    const hex = this.computedValue.toString('hex');
                    return `linear-gradient(
                    45deg,
                    ${hex} 50%,
                    ${hex} 50%
                )`
                }
            },
            triggerStyle() {
                const { red, green, blue } = this.computedValue;
                const light = (red * 0.299 + green * 0.587 + blue * 0.114) > 186;

                return {
                    backgroundColor: '#ffffff',
                    backgroundImage: `
                    ${this.background},
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7),
                    linear-gradient(45deg, #c7c7c7 25%, transparent 25%, transparent 75%, #c7c7c7 75%, #c7c7c7)
                `,
                    backgroundSize: '100% 100%, 16px 16px, 16px 16px',
                    backgroundPosition: '0 0, 8px 8px, 0 0',
                    color: light ? '#000000' : '#FFFFFF',
                    textShadow: `0 0 2px ${light ? '#FFFFFFAA' : '#000000AA'}`
                }
            },

            isMobile() {
                return this.mobileNative && isMobile.any()
            },

            ariaRole() {
                if (!this.inline) {
                    return 'dialog'
                } else {
                    return undefined
                }
            }
        },
        watch: {
            modelValue(value) {
                this.computedValue = new Color$1(value);
            }
        },
        methods: {
            parseColor(color) {
                try {
                    return this.colorParser(color)
                } catch (e) {
                    return new Color$1()
                }
            },
            updateColor(value) {
                value.alpha = this.computedValue.alpha;
                this.computedValue = value;
                this.$emit('update:modelValue', value);
            },
            updateAlpha(alpha) {
                this.computedValue.alpha = alpha;
                this.$emit('update:modelValue', this.computedValue);
            },
            updateRGB() {
                this.$emit('update:modelValue', this.computedValue);
            },
            /*
             * Format color into string
             */
            formatValue(value) {
                return value ? this.colorFormatter(value, this) : null
            },

            /*
             * Toggle datepicker
             */
            togglePicker(active) {
                if (this.$refs.dropdown) {
                    const isActive = typeof active === 'boolean'
                        ? active
                        : !this.$refs.dropdown.isActive;
                    if (isActive) {
                        this.$refs.dropdown.isActive = isActive;
                    } else if (this.closeOnClick) {
                        this.$refs.dropdown.isActive = isActive;
                    }
                }
            },

            /*
             * Call default onFocus method and show datepicker
             */
            handleOnFocus(event) {
                this.onFocus(event);
                if (this.openOnFocus) {
                    this.togglePicker(true);
                }
            },

            /*
             * Toggle dropdown
             */
            toggle() {
                if (this.mobileNative && this.isMobile) {
                    const input = this.$refs.input.$refs.input;
                    input.focus();
                    input.click();
                    return
                }
                this.$refs.dropdown.toggle();
            },

            /*
             * Avoid dropdown toggle when is already visible
             */
            onInputClick(event) {
                if (this.$refs.dropdown.isActive) {
                    event.stopPropagation();
                }
            },

            /**
             * Keypress event that is bound to the document.
             */
            keyPress({ key }) {
                if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
                    this.togglePicker(false);
                }
            },

            /**
             * Emit 'blur' event on dropdown is not active (closed)
             */
            onActiveChange(value) {
                if (!value) {
                    this.onBlur();
                }
                /*
                 * Emit 'active-change' when on dropdown active state change
                 */
                this.$emit('active-change', value);
            }
        }
    };

    const _hoisted_1 = { class: "color-name" };
    const _hoisted_2 = { class: "colorpicker-header" };
    const _hoisted_3 = { class: "colorpicker-content" };
    const _hoisted_4 = { class: "colorpicker-footer" };

    function render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_b_button = vue.resolveComponent("b-button");
      const _component_b_colorpicker_h_s_l_representation_square = vue.resolveComponent("b-colorpicker-h-s-l-representation-square");
      const _component_b_colorpicker_h_s_l_representation_triangle = vue.resolveComponent("b-colorpicker-h-s-l-representation-triangle");
      const _component_b_colorpicker_alpha_slider = vue.resolveComponent("b-colorpicker-alpha-slider");
      const _component_b_input = vue.resolveComponent("b-input");
      const _component_b_field = vue.resolveComponent("b-field");
      const _component_b_dropdown_item = vue.resolveComponent("b-dropdown-item");
      const _component_b_dropdown = vue.resolveComponent("b-dropdown");

      return (vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["colorpicker control", [_ctx.size, {'is-expanded': $props.expanded}]])
      }, [
        (!$options.isMobile || $props.inline)
          ? (vue.openBlock(), vue.createBlock(_component_b_dropdown, {
              key: 0,
              ref: "dropdown",
              position: $props.position,
              expanded: $props.expanded,
              disabled: $props.disabled,
              inline: $props.inline,
              "mobile-modal": $props.mobileModal,
              "trap-focus": $props.trapFocus,
              "aria-role": $options.ariaRole,
              "append-to-body": $props.appendToBody,
              "append-to-body-copy-parent": "",
              onActiveChange: $options.onActiveChange
            }, vue.createSlots({
              default: vue.withCtx(() => [
                vue.createVNode(_component_b_dropdown_item, {
                  disabled: $props.disabled,
                  focusable: $props.focusable,
                  custom: "",
                  class: vue.normalizeClass({'dropdown-horizontal-colorpicker': $props.horizontalColorPicker})
                }, {
                  default: vue.withCtx(() => [
                    vue.createElementVNode("div", null, [
                      vue.createElementVNode("header", _hoisted_2, [
                        (_ctx.$slots.header !== undefined && _ctx.$slots.header.length)
                          ? vue.renderSlot(_ctx.$slots, "header", { key: 0 })
                          : vue.createCommentVNode("v-if", true)
                      ]),
                      vue.createElementVNode("div", _hoisted_3, [
                        ($props.representation === 'square')
                          ? (vue.openBlock(), vue.createBlock(_component_b_colorpicker_h_s_l_representation_square, {
                              key: 0,
                              value: $options.computedValue,
                              onInput: $options.updateColor
                            }, null, 8 /* PROPS */, ["value", "onInput"]))
                          : (vue.openBlock(), vue.createBlock(_component_b_colorpicker_h_s_l_representation_triangle, {
                              key: 1,
                              value: $options.computedValue,
                              onInput: $options.updateColor
                            }, null, 8 /* PROPS */, ["value", "onInput"]))
                      ])
                    ]),
                    vue.createElementVNode("footer", _hoisted_4, [
                      ($props.alpha)
                        ? (vue.openBlock(), vue.createBlock(_component_b_colorpicker_alpha_slider, {
                            key: 0,
                            value: $options.computedValue.alpha,
                            onInput: $options.updateAlpha,
                            color: $options.computedValue
                          }, null, 8 /* PROPS */, ["value", "onInput", "color"]))
                        : vue.createCommentVNode("v-if", true),
                      vue.renderSlot(_ctx.$slots, "footer", { color: $options.computedValue }, () => [
                        vue.createVNode(_component_b_field, {
                          class: "colorpicker-fields",
                          grouped: ""
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(_component_b_field, {
                              horizontal: "",
                              label: "R"
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(_component_b_input, {
                                  type: "number",
                                  modelValue: $options.computedValue.red,
                                  "onUpdate:modelValue": [
                                    _cache[0] || (_cache[0] = $event => (($options.computedValue.red) = $event)),
                                    $options.updateRGB
                                  ],
                                  modelModifiers: { number: true },
                                  size: "is-small",
                                  "aria-label": "Red"
                                }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              _: 1 /* STABLE */
                            }),
                            vue.createVNode(_component_b_field, {
                              horizontal: "",
                              label: "G"
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(_component_b_input, {
                                  type: "number",
                                  modelValue: $options.computedValue.green,
                                  "onUpdate:modelValue": [
                                    _cache[1] || (_cache[1] = $event => (($options.computedValue.green) = $event)),
                                    $options.updateRGB
                                  ],
                                  modelModifiers: { number: true },
                                  size: "is-small",
                                  "aria-label": "Green"
                                }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              _: 1 /* STABLE */
                            }),
                            vue.createVNode(_component_b_field, {
                              horizontal: "",
                              label: "B"
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(_component_b_input, {
                                  type: "number",
                                  modelValue: $options.computedValue.blue,
                                  "onUpdate:modelValue": [
                                    _cache[2] || (_cache[2] = $event => (($options.computedValue.blue) = $event)),
                                    $options.updateRGB
                                  ],
                                  modelModifiers: { number: true },
                                  size: "is-small",
                                  "aria-label": "Blue"
                                }, null, 8 /* PROPS */, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              _: 1 /* STABLE */
                            })
                          ]),
                          _: 1 /* STABLE */
                        })
                      ])
                    ])
                  ]),
                  _: 3 /* FORWARDED */
                }, 8 /* PROPS */, ["disabled", "focusable", "class"])
              ]),
              _: 2 /* DYNAMIC */
            }, [
              (!$props.inline)
                ? {
                    name: "trigger",
                    fn: vue.withCtx(() => [
                      vue.renderSlot(_ctx.$slots, "trigger", {}, () => [
                        vue.createVNode(_component_b_button, {
                          style: vue.normalizeStyle($options.triggerStyle),
                          expanded: $props.expanded,
                          disabled: $props.disabled
                        }, {
                          default: vue.withCtx(() => [
                            vue.createElementVNode("span", _hoisted_1, vue.toDisplayString($props.colorFormatter($options.computedValue)), 1 /* TEXT */)
                          ]),
                          _: 1 /* STABLE */
                        }, 8 /* PROPS */, ["style", "expanded", "disabled"])
                      ])
                    ]),
                    key: "0"
                  }
                : undefined
            ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["position", "expanded", "disabled", "inline", "mobile-modal", "trap-focus", "aria-role", "append-to-body", "onActiveChange"]))
          : vue.createCommentVNode("v-if", true)
      ], 2 /* CLASS */))
    }

    script.render = render;
    script.__file = "src/components/colorpicker/Colorpicker.vue";

    var use = function use(plugin) {
      if (typeof window !== 'undefined' && window.Vue) {
        window.Vue.use(plugin);
      }
    };

    // use `name` to register a Functional Component which will become unresolvable
    // in production build due to name mangling.
    var registerComponent = function registerComponent(Vue, component, name) {
      Vue.component(name || component.name, component);
    };

    var Plugin = {
      install: function install(Vue) {
        registerComponent(Vue, script);
      }
    };
    use(Plugin);

    exports.BColorpicker = script;
    exports.default = Plugin;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
