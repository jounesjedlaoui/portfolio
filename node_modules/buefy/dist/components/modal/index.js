/*! Buefy v0.1.3 | MIT License | github.com/buefy/buefy */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Modal = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }

  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }

  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  var findFocusable = function findFocusable(element) {
    var programmatic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!element) {
      return null;
    }
    if (programmatic) {
      return element.querySelectorAll('*[tabindex="-1"]');
    }
    return element.querySelectorAll("a[href]:not([tabindex=\"-1\"]),\n                                     area[href],\n                                     input:not([disabled]),\n                                     select:not([disabled]),\n                                     textarea:not([disabled]),\n                                     button:not([disabled]),\n                                     iframe,\n                                     object,\n                                     embed,\n                                     *[tabindex]:not([tabindex=\"-1\"]),\n                                     *[contenteditable]");
  };
  var onKeyDown;
  var beforeMount = function beforeMount(el, _ref) {
    var _ref$value = _ref.value,
      value = _ref$value === void 0 ? true : _ref$value;
    if (value) {
      var focusable = findFocusable(el);
      var focusableProg = findFocusable(el, true);
      if (focusable && focusable.length > 0) {
        onKeyDown = function onKeyDown(event) {
          // Need to get focusable each time since it can change between key events
          // ex. changing month in a datepicker
          focusable = findFocusable(el);
          focusableProg = findFocusable(el, true);
          var firstFocusable = focusable[0];
          var lastFocusable = focusable[focusable.length - 1];
          if (event.target === firstFocusable && event.shiftKey && event.key === 'Tab') {
            event.preventDefault();
            lastFocusable.focus();
          } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === 'Tab') {
            event.preventDefault();
            firstFocusable.focus();
          }
        };
        el.addEventListener('keydown', onKeyDown);
      }
    }
  };
  var unmounted = function unmounted(el) {
    el.removeEventListener('keydown', onKeyDown);
  };
  var directive = {
    beforeMount: beforeMount,
    unmounted: unmounted
  };
  var trapFocus = directive;

  function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

  /**
   * Merge function to replace Object.assign with deep merging possibility
   */
  var isObject = function isObject(item) {
    return _typeof(item) === 'object' && !Array.isArray(item);
  };
  var mergeFn = function mergeFn(target, source) {
    var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (deep || !Object.assign) {
      var isDeep = function isDeep(prop) {
        return isObject(source[prop]) && target !== null && Object.prototype.hasOwnProperty.call(target, prop) && isObject(target[prop]);
      };
      var replaced = Object.getOwnPropertyNames(source).map(function (prop) {
        return _defineProperty({}, prop, isDeep(prop) ? mergeFn(target[prop], source[prop], deep) : source[prop]);
      }).reduce(function (a, b) {
        return _objectSpread$1(_objectSpread$1({}, a), b);
      }, {});
      return _objectSpread$1(_objectSpread$1({}, target), replaced);
    } else {
      return Object.assign(target, source);
    }
  };
  var merge = mergeFn;
  function removeElement(el) {
    if (typeof el.remove !== 'undefined') {
      el.remove();
    } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {
      el.parentNode.removeChild(el);
    }
  }

  // references
  // - https://github.com/vuejs/core/blob/1c525f75a3d17a6356d5f66765623c0ae7c0ebcc/packages/runtime-core/src/apiCreateApp.ts#L361
  // - https://github.com/vuejs/core/blob/1c525f75a3d17a6356d5f66765623c0ae7c0ebcc/packages/runtime-core/src/component.ts#L1036-L1054
  //
  // we cannot access getExposeProxy since it is not exported from `vue`, though,
  // its purpose seems to be one-time initialization of component.exposeProxy,
  // which should have been done by this function call
  function getComponentFromVNode(vnode) {
    if (!vnode) {
      return undefined;
    }
    var component = vnode.component;
    if (!component) {
      return undefined;
    }
    return component.exposed && component.exposeProxy || component.proxy;
  }

  // Copies the context from a given app to another app.
  //
  // This function is necessary to programmatically mount a component; e.g.,
  // Modal.
  // Since Vue 3's app can mount only one component, we have to create a new app
  // to mount another new component.
  // If we create a new app with `createApp` API, no context (e.g., installed
  // components, directives) is available on the new app.
  // This function can copy the context from the host app to the new app.
  //
  // Depends on what Vue internally does: https://github.com/vuejs/core/blob/b775b71c788499ec7ee58bc2cf4cd04ed388e072/packages/runtime-core/src/apiCreateApp.ts#L170-L190
  //
  // This function also should take care of compatiblity with other plugins.
  // We need a generic solution, though, it fixes compatiblity issues of
  // individual plugins for now.
  function copyAppContext(src, dest) {
    // replacing _context won't work because methods of app bypasses app._context
    var srcContext = src._context;
    var destContext = dest._context;
    destContext.config = srcContext.config;
    destContext.mixins = srcContext.mixins;
    destContext.components = srcContext.components;
    destContext.directives = srcContext.directives;
    destContext.provides = srcContext.provides;
    destContext.optionsCache = srcContext.optionsCache;
    destContext.propsCache = srcContext.propsCache;
    destContext.emitsCache = srcContext.emitsCache;
    // vue-i18n support: https://github.com/ntohq/buefy-next/issues/153
    if ('__VUE_I18N_SYMBOL__' in src) {
      dest.__VUE_I18N_SYMBOL__ = src.__VUE_I18N_SYMBOL__;
    }
  }

  var config = {
    defaultContainerElement: null,
    defaultIconPack: 'mdi',
    defaultIconComponent: null,
    defaultIconPrev: 'chevron-left',
    defaultIconNext: 'chevron-right',
    defaultLocale: undefined,
    defaultDialogConfirmText: null,
    defaultDialogCancelText: null,
    defaultSnackbarDuration: 3500,
    defaultSnackbarPosition: null,
    defaultToastDuration: 2000,
    defaultToastPosition: null,
    defaultNotificationDuration: 2000,
    defaultNotificationPosition: null,
    defaultTooltipType: 'is-primary',
    defaultTooltipDelay: null,
    defaultTooltipCloseDelay: null,
    defaultSidebarDelay: null,
    defaultInputAutocomplete: 'on',
    defaultDateFormatter: null,
    defaultDateParser: null,
    defaultDateCreator: null,
    defaultTimeCreator: null,
    defaultDayNames: null,
    defaultMonthNames: null,
    defaultFirstDayOfWeek: null,
    defaultUnselectableDaysOfWeek: null,
    defaultTimeFormatter: null,
    defaultTimeParser: null,
    defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],
    defaultModalScroll: null,
    defaultDatepickerMobileNative: true,
    defaultTimepickerMobileNative: true,
    defaultTimepickerMobileModal: true,
    defaultNoticeQueue: true,
    defaultInputHasCounter: true,
    /**
     * Whether `class`, `style`, and `id` are applied to the root element in
     * components that are affected by Vue 3 change in fallthgourh beahvior.
     * See: https://github.com/ntohq/buefy-next/issues/16
     */
    defaultCompatFallthrough: true,
    defaultTaginputHasCounter: true,
    defaultUseHtml5Validation: true,
    defaultDropdownMobileModal: true,
    defaultFieldLabelPosition: null,
    defaultDatepickerYearsRange: [-100, 10],
    defaultDatepickerNearbyMonthDays: true,
    defaultDatepickerNearbySelectableMonthDays: false,
    defaultDatepickerShowWeekNumber: false,
    defaultDatepickerWeekNumberClickable: false,
    defaultDatepickerMobileModal: true,
    defaultTrapFocus: true,
    defaultAutoFocus: true,
    defaultButtonRounded: false,
    defaultSwitchRounded: true,
    defaultCarouselInterval: 3500,
    defaultTabsExpanded: false,
    defaultTabsAnimated: true,
    defaultTabsType: null,
    defaultStatusIcon: true,
    defaultProgrammaticPromise: false,
    defaultLinkTags: ['a', 'button', 'input', 'router-link', 'nuxt-link', 'n-link', 'RouterLink', 'NuxtLink', 'NLink'],
    defaultImageWebpFallback: null,
    defaultImageLazy: true,
    defaultImageResponsive: true,
    defaultImageRatio: null,
    defaultImageSrcsetFormatter: null,
    defaultBreadcrumbTag: 'a',
    defaultBreadcrumbAlign: 'is-left',
    defaultBreadcrumbSeparator: '',
    defaultBreadcrumbSize: 'is-medium',
    customIconPacks: null
  };

  var script = {
      name: 'BModal',
      directives: {
          trapFocus
      },
      props: {
          modelValue: Boolean,
          component: [Object, Function, String],
          content: [String, Array],
          programmatic: Boolean,
          props: Object,
          events: Object,
          width: {
              type: [String, Number],
              default: 960
          },
          hasModalCard: Boolean,
          animation: {
              type: String,
              default: 'zoom-out'
          },
          canCancel: {
              type: [Array, Boolean],
              default: () => {
                  return config.defaultModalCanCancel
              }
          },
          cancelCallback: {
              type: Function,
              default: () => {}
          },
          scroll: {
              type: String,
              default: () => {
                  return 'clip'
              },
              validator: (value) => {
                  return [
                      'clip',
                      'keep'
                  ].indexOf(value) >= 0
              }
          },
          fullScreen: Boolean,
          trapFocus: {
              type: Boolean,
              default: () => {
                  return config.defaultTrapFocus
              }
          },
          autoFocus: {
              type: Boolean,
              default: () => {
                  return config.defaultAutoFocus
              }
          },
          customClass: String,
          customContentClass: [String, Array, Object],
          ariaRole: {
              type: String,
              validator: (value) => {
                  return [
                      'dialog',
                      'alertdialog'
                  ].indexOf(value) >= 0
              }
          },
          ariaModal: Boolean,
          ariaLabel: {
              type: String,
              validator: (value) => {
                  return Boolean(value)
              }
          },
          closeButtonAriaLabel: String,
          destroyOnHide: {
              type: Boolean,
              default: true
          },
          renderOnMounted: {
              type: Boolean,
              default: false
          }
      },
      emits: [
          'after-enter',
          'after-leave',
          'cancel',
          'close',
          'update:modelValue'
      ],
      data() {
          return {
              isActive: this.modelValue || false,
              savedScrollTop: null,
              newWidth: typeof this.width === 'number'
                  ? this.width + 'px'
                  : this.width,
              animating: !this.modelValue,
              destroyed: !(this.modelValue || this.renderOnMounted)
          }
      },
      computed: {
          cancelOptions() {
              return typeof this.canCancel === 'boolean'
                  ? this.canCancel
                      ? config.defaultModalCanCancel
                      : []
                  : this.canCancel
          },
          showX() {
              return this.cancelOptions.indexOf('x') >= 0
          },
          customStyle() {
              if (!this.fullScreen) {
                  return { maxWidth: this.newWidth }
              }
              return null
          }
      },
      watch: {
          modelValue(value) {
              this.isActive = value;
          },
          isActive(value) {
              if (value) this.destroyed = false;
              this.handleScroll();
              this.$nextTick(() => {
                  if (value && this.$el && this.$el.focus && this.autoFocus) {
                      this.$el.focus();
                  }
              });
          }
      },
      methods: {
          handleScroll() {
              if (typeof window === 'undefined') return

              if (this.scroll === 'clip') {
                  if (this.isActive) {
                      document.documentElement.classList.add('is-clipped');
                  } else {
                      document.documentElement.classList.remove('is-clipped');
                  }
                  return
              }

              this.savedScrollTop = !this.savedScrollTop
                  ? document.documentElement.scrollTop
                  : this.savedScrollTop;

              if (this.isActive) {
                  document.body.classList.add('is-noscroll');
              } else {
                  document.body.classList.remove('is-noscroll');
              }

              if (this.isActive) {
                  document.body.style.top = `-${this.savedScrollTop}px`;
                  return
              }

              document.documentElement.scrollTop = this.savedScrollTop;
              document.body.style.top = null;
              this.savedScrollTop = null;
          },

          /**
          * Close the Modal if canCancel and call the cancelCallback prop (function).
          */
          cancel(method) {
              if (this.cancelOptions.indexOf(method) < 0) return
              this.$emit('cancel', arguments);
              this.cancelCallback.apply(null, arguments);
              this.close();
          },

          /**
          * Call the cancelCallback prop (function).
          * Emit events, and destroy modal if it's programmatic.
          */
          close() {
              this.$emit('close');
              this.$emit('update:modelValue', false);

              // Timeout for the animation complete before destroying
              if (this.programmatic) {
                  this.isActive = false;
                  setTimeout(() => {
                      removeElement(this.$el);
                  }, 150);
              }
          },

          /**
          * Keypress event that is bound to the document.
          */
          keyPress({ key }) {
              if (this.isActive && (key === 'Escape' || key === 'Esc')) this.cancel('escape');
          },

          /**
          * Transition after-enter hook
          */
          afterEnter() {
              this.animating = false;
              this.$emit('after-enter');
          },

          /**
          * Transition before-leave hook
          */
          beforeLeave() {
              this.animating = true;
          },

          /**
          * Transition after-leave hook
          */
          afterLeave() {
              if (this.destroyOnHide) {
                  this.destroyed = true;
              }
              this.$emit('after-leave');
          }
      },
      created() {
          if (typeof window !== 'undefined') {
              document.addEventListener('keyup', this.keyPress);
          }
      },
      mounted() {
          if (this.programmatic) {
              // Insert the Modal component in body tag
              // only if it's programmatic
              // the following line used be in `beforeMount`
              // but $el is null at `beforeMount`
              document.body.appendChild(this.$el);
              this.isActive = true;
          } else if (this.isActive) this.handleScroll();
      },
      beforeUnmount() {
          if (typeof window !== 'undefined') {
              document.removeEventListener('keyup', this.keyPress);
              // reset scroll
              document.documentElement.classList.remove('is-clipped');
              const savedScrollTop = !this.savedScrollTop
                  ? document.documentElement.scrollTop
                  : this.savedScrollTop;
              document.body.classList.remove('is-noscroll');
              document.documentElement.scrollTop = savedScrollTop;
              document.body.style.top = null;
          }
      }
  };

  const _hoisted_1 = ["role", "aria-label", "aria-modal"];
  const _hoisted_2 = ["innerHTML"];
  const _hoisted_3 = ["aria-label"];

  function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _directive_trap_focus = vue.resolveDirective("trap-focus");

    return (vue.openBlock(), vue.createBlock(vue.Transition, {
      name: $props.animation,
      onAfterEnter: $options.afterEnter,
      onBeforeLeave: $options.beforeLeave,
      onAfterLeave: $options.afterLeave
    }, {
      default: vue.withCtx(() => [
        (!$data.destroyed)
          ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
              key: 0,
              class: vue.normalizeClass(["modal is-active", [{'is-full-screen': $props.fullScreen}, $props.customClass]]),
              tabindex: "-1",
              role: $props.ariaRole,
              "aria-label": $props.ariaLabel,
              "aria-modal": $props.ariaModal || undefined
            }, [
              vue.createElementVNode("div", {
                class: "modal-background",
                onClick: _cache[0] || (_cache[0] = $event => ($options.cancel('outside')))
              }),
              vue.createElementVNode("div", {
                class: vue.normalizeClass(["animation-content", [{ 'modal-content': !$props.hasModalCard }, $props.customContentClass]]),
                style: vue.normalizeStyle($options.customStyle)
              }, [
                ($props.component)
                  ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent($props.component), vue.mergeProps({ key: 0 }, $props.props, vue.toHandlers($props.events), {
                      "can-cancel": $props.canCancel,
                      onClose: $options.close
                    }), null, 16 /* FULL_PROPS */, ["can-cancel", "onClose"]))
                  : ($props.content)
                    ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                        vue.createCommentVNode(" eslint-disable-next-line vue/no-v-html "),
                        vue.createElementVNode("div", { innerHTML: $props.content }, null, 8 /* PROPS */, _hoisted_2)
                      ], 64 /* STABLE_FRAGMENT */))
                    : vue.renderSlot(_ctx.$slots, "default", {
                        key: 2,
                        canCancel: $props.canCancel,
                        close: $options.close
                      }),
                ($options.showX)
                  ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("button", {
                      key: 3,
                      type: "button",
                      class: "modal-close is-large",
                      "aria-label": $props.closeButtonAriaLabel,
                      onClick: _cache[1] || (_cache[1] = $event => ($options.cancel('x')))
                    }, null, 8 /* PROPS */, _hoisted_3)), [
                      [vue.vShow, !$data.animating]
                    ])
                  : vue.createCommentVNode("v-if", true)
              ], 6 /* CLASS, STYLE */)
            ], 10 /* CLASS, PROPS */, _hoisted_1)), [
              [vue.vShow, $data.isActive],
              [_directive_trap_focus, $props.trapFocus]
            ])
          : vue.createCommentVNode("v-if", true)
      ]),
      _: 3 /* FORWARDED */
    }, 8 /* PROPS */, ["name", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]))
  }

  script.render = render;
  script.__file = "src/components/modal/Modal.vue";

  var use = function use(plugin) {
    if (typeof window !== 'undefined' && window.Vue) {
      window.Vue.use(plugin);
    }
  };

  // use `name` to register a Functional Component which will become unresolvable
  // in production build due to name mangling.
  var registerComponent = function registerComponent(Vue, component, name) {
    Vue.component(name || component.name, component);
  };
  var registerComponentProgrammatic = function registerComponentProgrammatic(Vue, property, component) {
    if (!Vue.config.globalProperties.$buefy) Vue.config.globalProperties.$buefy = {};
    Vue.config.globalProperties.$buefy[property] = component;
  };

  function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  var ModalProgrammatic = /*#__PURE__*/function () {
    function ModalProgrammatic(app) {
      _classCallCheck(this, ModalProgrammatic);
      this.app = app; // may be undefined in the testing environment
    }
    _createClass(ModalProgrammatic, [{
      key: "open",
      value: function open(params) {
        if (typeof params === 'string') {
          params = {
            content: params
          };
        }
        var defaultParam = {
          programmatic: true
        };
        if (params.parent) {
          delete params.parent;
        }
        var slot;
        if (Array.isArray(params.content)) {
          slot = params.content;
          delete params.content;
        }
        var propsData = merge(defaultParam, params);
        var container = document.createElement('div');
        // Vue 3 requires a new app to mount another component
        var vueInstance = vue.createApp({
          data: function data() {
            return {
              modalVNode: null
            };
          },
          methods: {
            close: function close() {
              var modal = getComponentFromVNode(this.modalVNode);
              if (modal) {
                modal.close();
              }
            }
          },
          render: function render() {
            this.modalVNode = vue.h(script, _objectSpread(_objectSpread({}, propsData), {}, {
              onClose: function onClose() {
                vueInstance.unmount();
              },
              // intentionally overrides propsData.onCancel
              // to prevent propsData.onCancel from receiving a "cancel" event
              onCancel: function onCancel() {},
              cancelCallback: function cancelCallback() {
                if (propsData.onCancel != null) {
                  propsData.onCancel.apply(propsData, arguments);
                }
              }
            }), slot ? {
              "default": function _default() {
                return slot;
              }
            } : undefined);
            return this.modalVNode;
          }
        });
        if (this.app) {
          copyAppContext(this.app, vueInstance);
        }
        return vueInstance.mount(container);
      }
    }]);
    return ModalProgrammatic;
  }();
  var Plugin = {
    install: function install(Vue) {
      registerComponent(Vue, script);
      registerComponentProgrammatic(Vue, 'modal', new ModalProgrammatic(Vue));
    }
  };
  use(Plugin);

  exports.BModal = script;
  exports.ModalProgrammatic = ModalProgrammatic;
  exports.default = Plugin;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
