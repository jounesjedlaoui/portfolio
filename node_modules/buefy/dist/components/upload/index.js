/*! Buefy v0.1.3 | MIT License | github.com/buefy/buefy */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Upload = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }

  var config = {
    defaultContainerElement: null,
    defaultIconPack: 'mdi',
    defaultIconComponent: null,
    defaultIconPrev: 'chevron-left',
    defaultIconNext: 'chevron-right',
    defaultLocale: undefined,
    defaultDialogConfirmText: null,
    defaultDialogCancelText: null,
    defaultSnackbarDuration: 3500,
    defaultSnackbarPosition: null,
    defaultToastDuration: 2000,
    defaultToastPosition: null,
    defaultNotificationDuration: 2000,
    defaultNotificationPosition: null,
    defaultTooltipType: 'is-primary',
    defaultTooltipDelay: null,
    defaultTooltipCloseDelay: null,
    defaultSidebarDelay: null,
    defaultInputAutocomplete: 'on',
    defaultDateFormatter: null,
    defaultDateParser: null,
    defaultDateCreator: null,
    defaultTimeCreator: null,
    defaultDayNames: null,
    defaultMonthNames: null,
    defaultFirstDayOfWeek: null,
    defaultUnselectableDaysOfWeek: null,
    defaultTimeFormatter: null,
    defaultTimeParser: null,
    defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],
    defaultModalScroll: null,
    defaultDatepickerMobileNative: true,
    defaultTimepickerMobileNative: true,
    defaultTimepickerMobileModal: true,
    defaultNoticeQueue: true,
    defaultInputHasCounter: true,
    /**
     * Whether `class`, `style`, and `id` are applied to the root element in
     * components that are affected by Vue 3 change in fallthgourh beahvior.
     * See: https://github.com/ntohq/buefy-next/issues/16
     */
    defaultCompatFallthrough: true,
    defaultTaginputHasCounter: true,
    defaultUseHtml5Validation: true,
    defaultDropdownMobileModal: true,
    defaultFieldLabelPosition: null,
    defaultDatepickerYearsRange: [-100, 10],
    defaultDatepickerNearbyMonthDays: true,
    defaultDatepickerNearbySelectableMonthDays: false,
    defaultDatepickerShowWeekNumber: false,
    defaultDatepickerWeekNumberClickable: false,
    defaultDatepickerMobileModal: true,
    defaultTrapFocus: true,
    defaultAutoFocus: true,
    defaultButtonRounded: false,
    defaultSwitchRounded: true,
    defaultCarouselInterval: 3500,
    defaultTabsExpanded: false,
    defaultTabsAnimated: true,
    defaultTabsType: null,
    defaultStatusIcon: true,
    defaultProgrammaticPromise: false,
    defaultLinkTags: ['a', 'button', 'input', 'router-link', 'nuxt-link', 'n-link', 'RouterLink', 'NuxtLink', 'NLink'],
    defaultImageWebpFallback: null,
    defaultImageLazy: true,
    defaultImageResponsive: true,
    defaultImageRatio: null,
    defaultImageSrcsetFormatter: null,
    defaultBreadcrumbTag: 'a',
    defaultBreadcrumbAlign: 'is-left',
    defaultBreadcrumbSeparator: '',
    defaultBreadcrumbSize: 'is-medium',
    customIconPacks: null
  };

  var _excluded = ["style", "class", "id"];
  var CompatFallthroughMixin = {
    inheritAttrs: false,
    props: {
      compatFallthrough: {
        type: Boolean,
        "default": function _default() {
          return config.defaultCompatFallthrough;
        }
      }
    },
    computed: {
      rootAttrs: function rootAttrs() {
        return this.compatFallthrough ? {
          "class": this.$attrs["class"],
          style: this.$attrs.style,
          id: this.$attrs.id
        } : {};
      },
      fallthroughAttrs: function fallthroughAttrs() {
        if (this.compatFallthrough) {
          var _this$$attrs = this.$attrs;
            _this$$attrs.style;
            _this$$attrs["class"];
            _this$$attrs.id;
            var rest = _objectWithoutProperties(_this$$attrs, _excluded);
          return rest;
        } else {
          return this.$attrs;
        }
      }
    }
  };

  var FormElementMixin = {
    props: {
      size: String,
      expanded: Boolean,
      loading: Boolean,
      rounded: Boolean,
      icon: String,
      iconPack: String,
      // Native options to use in HTML5 validation
      autocomplete: String,
      maxlength: [Number, String],
      useHtml5Validation: {
        type: Boolean,
        "default": function _default() {
          return config.defaultUseHtml5Validation;
        }
      },
      validationMessage: String,
      locale: {
        type: [String, Array],
        "default": function _default() {
          return config.defaultLocale;
        }
      },
      statusIcon: {
        type: Boolean,
        "default": function _default() {
          return config.defaultStatusIcon;
        }
      }
    },
    emits: ['blur', 'focus'],
    data: function data() {
      return {
        isValid: true,
        isFocused: false,
        newIconPack: this.iconPack || config.defaultIconPack
      };
    },
    computed: {
      /**
       * Find parent Field, max 3 levels deep.
       */
      parentField: function parentField() {
        var parent = this.$parent;
        for (var i = 0; i < 3; i++) {
          if (parent && !parent.$data._isField) {
            parent = parent.$parent;
          }
        }
        return parent;
      },
      /**
       * Get the type prop from parent if it's a Field.
       */
      statusType: function statusType() {
        var _ref = this.parentField || {},
          newType = _ref.newType;
        if (!newType) return;
        if (typeof newType === 'string') {
          return newType;
        } else {
          for (var key in newType) {
            if (newType[key]) {
              return key;
            }
          }
        }
      },
      /**
       * Get the message prop from parent if it's a Field.
       */
      statusMessage: function statusMessage() {
        if (!this.parentField) return;
        return this.parentField.newMessage || this.parentField.$slots.message;
      },
      /**
       * Fix icon size for inputs, large was too big
       */
      iconSize: function iconSize() {
        switch (this.size) {
          case 'is-small':
            return this.size;
          case 'is-medium':
            return;
          case 'is-large':
            return this.newIconPack === 'mdi' ? 'is-medium' : '';
        }
      }
    },
    methods: {
      /**
       * Focus method that work dynamically depending on the component.
       */
      focus: function focus() {
        var el = this.getElement();
        if (el === undefined) return;
        this.$nextTick(function () {
          if (el) el.focus();
        });
      },
      onBlur: function onBlur($event) {
        this.isFocused = false;
        this.$emit('blur', $event);
        this.checkHtml5Validity();
      },
      onFocus: function onFocus($event) {
        this.isFocused = true;
        this.$emit('focus', $event);
      },
      getElement: function getElement() {
        var el = this.$refs[this.$data._elementRef];
        while (el != null && '$refs' in el) {
          el = el.$refs[el.$data._elementRef];
        }
        return el;
      },
      setInvalid: function setInvalid() {
        var type = 'is-danger';
        var message = this.validationMessage || this.getElement().validationMessage;
        this.setValidity(type, message);
      },
      setValidity: function setValidity(type, message) {
        var _this = this;
        this.$nextTick(function () {
          if (_this.parentField) {
            // Set type only if not defined
            if (!_this.parentField.type) {
              _this.parentField.newType = type;
            }
            // Set message only if not defined
            if (!_this.parentField.message) {
              _this.parentField.newMessage = message;
            }
          }
        });
      },
      /**
       * Check HTML5 validation, set isValid property.
       * If validation fail, send 'is-danger' type,
       * and error message to parent if it's a Field.
       */
      checkHtml5Validity: function checkHtml5Validity() {
        if (!this.useHtml5Validation) return;
        var el = this.getElement();
        if (el == null) return;
        if (!el.checkValidity()) {
          this.setInvalid();
          this.isValid = false;
        } else {
          this.setValidity(null, null);
          this.isValid = true;
        }
        return this.isValid;
      }
    }
  };

  // Polyfills for SSR

  var isSSR = typeof window === 'undefined';
  var File = isSSR ? Object : window.File;

  var script = {
      name: 'BUpload',
      mixins: [CompatFallthroughMixin, FormElementMixin],
      props: {
          modelValue: {
              type: [Object, Function, File, Array]
          },
          multiple: Boolean,
          disabled: Boolean,
          accept: String,
          dragDrop: Boolean,
          type: {
              type: String,
              default: 'is-primary'
          },
          native: {
              type: Boolean,
              default: false
          },
          expanded: {
              type: Boolean,
              default: false
          },
          rounded: {
              type: Boolean,
              default: false
          }
      },
      emits: ['invalid', 'update:modelValue'],
      data() {
          return {
              newValue: this.modelValue,
              dragDropFocus: false,
              _elementRef: 'input'
          }
      },
      computed: {
          disabledOrUndefined() {
              // On Vue 3, setting a boolean attribute `false` does not remove it,
              // `true` or `undefined` has to be given to remove it.
              return this.disabled || undefined
          }
      },
      watch: {
          /**
           *   When v-model is changed:
           *   1. Set internal value.
           *   2. Reset internal input file value
           *   3. If it's invalid, validate again.
           */
          modelValue(value) {
              this.newValue = value;
              if (!value || (Array.isArray(value) && value.length === 0)) {
                  this.$refs.input.value = null;
              }
              !this.isValid && !this.dragDrop && this.checkHtml5Validity();
          }
      },
      methods: {
          /**
          * Listen change event on input type 'file',
          * emit 'input' event and validate
          */
          onFileChange(event) {
              if (this.disabled || this.loading) return
              if (this.dragDrop) this.updateDragDropFocus(false);
              const value = event.target.files || event.dataTransfer.files;
              if (value.length === 0) {
                  if (!this.newValue) return
                  if (this.native) this.newValue = null;
              } else if (!this.multiple) {
                  // only one element in case drag drop mode and isn't multiple
                  if (this.dragDrop && value.length !== 1) return
                  else {
                      const file = value[0];
                      if (this.checkType(file)) this.newValue = file;
                      else if (this.newValue) {
                          this.newValue = null;
                          this.clearInput();
                      } else {
                          // Force input back to empty state and recheck validity
                          this.clearInput();
                          this.checkHtml5Validity();
                          return
                      }
                  }
              } else {
                  // always new values if native or undefined local
                  let newValues = false;
                  if (this.native || !this.newValue) {
                      this.newValue = [];
                      newValues = true;
                  }
                  for (let i = 0; i < value.length; i++) {
                      const file = value[i];
                      if (this.checkType(file)) {
                          this.newValue.push(file);
                          newValues = true;
                      }
                  }
                  if (!newValues) return
              }
              this.$emit('update:modelValue', this.newValue);
              !this.dragDrop && this.checkHtml5Validity();
          },

          /*
          * Reset file input value
          */
          clearInput() {
              this.$refs.input.value = null;
          },

          /**
          * Listen drag-drop to update internal variable
          */
          updateDragDropFocus(focus) {
              if (!this.disabled && !this.loading) {
                  this.dragDropFocus = focus;
              }
          },

          /**
          * Check mime type of file
          */
          checkType(file) {
              if (!this.accept) return true
              const types = this.accept.split(',');
              if (types.length === 0) return true
              let valid = false;
              for (let i = 0; i < types.length && !valid; i++) {
                  const type = types[i].trim();
                  if (type) {
                      if (type.substring(0, 1) === '.') {
                          // check extension
                          const extension = file.name.toLowerCase().slice(-type.length);
                          if (extension === type.toLowerCase()) {
                              valid = true;
                          }
                      } else {
                          // check mime type
                          if (file.type.match(type)) {
                              valid = true;
                          }
                      }
                  }
              }
              if (!valid) this.$emit('invalid');
              return valid
          }
      }
  };

  const _hoisted_1 = ["multiple", "accept", "disabled"];

  function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createElementBlock("label", vue.mergeProps({ class: "upload control" }, _ctx.rootAttrs, {
      class: [{'is-expanded' : $props.expanded, 'is-rounded' : $props.rounded}]
    }), [
      (!$props.dragDrop)
        ? vue.renderSlot(_ctx.$slots, "default", { key: 0 })
        : (vue.openBlock(), vue.createElementBlock("div", {
            key: 1,
            class: vue.normalizeClass(["upload-draggable", [$props.type, {
                  'is-loading': _ctx.loading,
                  'is-disabled': $props.disabled,
                  'is-hovered': $data.dragDropFocus,
                  'is-expanded': $props.expanded,
              }]]),
            onDragover: _cache[0] || (_cache[0] = vue.withModifiers($event => ($options.updateDragDropFocus(true)), ["prevent"])),
            onDragleave: _cache[1] || (_cache[1] = vue.withModifiers($event => ($options.updateDragDropFocus(false)), ["prevent"])),
            onDragenter: _cache[2] || (_cache[2] = vue.withModifiers($event => ($options.updateDragDropFocus(true)), ["prevent"])),
            onDrop: _cache[3] || (_cache[3] = vue.withModifiers((...args) => ($options.onFileChange && $options.onFileChange(...args)), ["prevent"]))
          }, [
            vue.renderSlot(_ctx.$slots, "default")
          ], 34 /* CLASS, HYDRATE_EVENTS */)),
      vue.createElementVNode("input", vue.mergeProps({
        ref: "input",
        type: "file"
      }, _ctx.fallthroughAttrs, {
        multiple: $props.multiple,
        accept: $props.accept,
        disabled: $options.disabledOrUndefined,
        onChange: _cache[4] || (_cache[4] = (...args) => ($options.onFileChange && $options.onFileChange(...args)))
      }), null, 16 /* FULL_PROPS */, _hoisted_1)
    ], 16 /* FULL_PROPS */))
  }

  script.render = render;
  script.__file = "src/components/upload/Upload.vue";

  var use = function use(plugin) {
    if (typeof window !== 'undefined' && window.Vue) {
      window.Vue.use(plugin);
    }
  };

  // use `name` to register a Functional Component which will become unresolvable
  // in production build due to name mangling.
  var registerComponent = function registerComponent(Vue, component, name) {
    Vue.component(name || component.name, component);
  };

  var Plugin = {
    install: function install(Vue) {
      registerComponent(Vue, script);
    }
  };
  use(Plugin);

  exports.BUpload = script;
  exports.default = Plugin;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
