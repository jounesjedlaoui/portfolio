/*! Buefy v0.1.3 | MIT License | github.com/buefy/buefy */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
    typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Steps = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

    var config = {
      defaultContainerElement: null,
      defaultIconPack: 'mdi',
      defaultIconComponent: null,
      defaultIconPrev: 'chevron-left',
      defaultIconNext: 'chevron-right',
      defaultLocale: undefined,
      defaultDialogConfirmText: null,
      defaultDialogCancelText: null,
      defaultSnackbarDuration: 3500,
      defaultSnackbarPosition: null,
      defaultToastDuration: 2000,
      defaultToastPosition: null,
      defaultNotificationDuration: 2000,
      defaultNotificationPosition: null,
      defaultTooltipType: 'is-primary',
      defaultTooltipDelay: null,
      defaultTooltipCloseDelay: null,
      defaultSidebarDelay: null,
      defaultInputAutocomplete: 'on',
      defaultDateFormatter: null,
      defaultDateParser: null,
      defaultDateCreator: null,
      defaultTimeCreator: null,
      defaultDayNames: null,
      defaultMonthNames: null,
      defaultFirstDayOfWeek: null,
      defaultUnselectableDaysOfWeek: null,
      defaultTimeFormatter: null,
      defaultTimeParser: null,
      defaultModalCanCancel: ['escape', 'x', 'outside', 'button'],
      defaultModalScroll: null,
      defaultDatepickerMobileNative: true,
      defaultTimepickerMobileNative: true,
      defaultTimepickerMobileModal: true,
      defaultNoticeQueue: true,
      defaultInputHasCounter: true,
      /**
       * Whether `class`, `style`, and `id` are applied to the root element in
       * components that are affected by Vue 3 change in fallthgourh beahvior.
       * See: https://github.com/ntohq/buefy-next/issues/16
       */
      defaultCompatFallthrough: true,
      defaultTaginputHasCounter: true,
      defaultUseHtml5Validation: true,
      defaultDropdownMobileModal: true,
      defaultFieldLabelPosition: null,
      defaultDatepickerYearsRange: [-100, 10],
      defaultDatepickerNearbyMonthDays: true,
      defaultDatepickerNearbySelectableMonthDays: false,
      defaultDatepickerShowWeekNumber: false,
      defaultDatepickerWeekNumberClickable: false,
      defaultDatepickerMobileModal: true,
      defaultTrapFocus: true,
      defaultAutoFocus: true,
      defaultButtonRounded: false,
      defaultSwitchRounded: true,
      defaultCarouselInterval: 3500,
      defaultTabsExpanded: false,
      defaultTabsAnimated: true,
      defaultTabsType: null,
      defaultStatusIcon: true,
      defaultProgrammaticPromise: false,
      defaultLinkTags: ['a', 'button', 'input', 'router-link', 'nuxt-link', 'n-link', 'RouterLink', 'NuxtLink', 'NLink'],
      defaultImageWebpFallback: null,
      defaultImageLazy: true,
      defaultImageResponsive: true,
      defaultImageRatio: null,
      defaultImageSrcsetFormatter: null,
      defaultBreadcrumbTag: 'a',
      defaultBreadcrumbAlign: 'is-left',
      defaultBreadcrumbSeparator: '',
      defaultBreadcrumbSize: 'is-medium',
      customIconPacks: null
    };

    function _typeof(o) {
      "@babel/helpers - typeof";

      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
        return typeof o;
      } : function (o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
      }, _typeof(o);
    }

    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }

    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }

    function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
    function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

    /**
     * Checks if the flag is set
     * @param val
     * @param flag
     * @returns {boolean}
     */
    function hasFlag(val, flag) {
      return (val & flag) === flag;
    }

    /**
     * Asserts a value is beetween min and max
     * @param val
     * @param min
     * @param max
     * @returns {number}
     */
    function bound(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    /**
     * Merge function to replace Object.assign with deep merging possibility
     */
    var isObject = function isObject(item) {
      return _typeof(item) === 'object' && !Array.isArray(item);
    };
    var mergeFn = function mergeFn(target, source) {
      var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (deep || !Object.assign) {
        var isDeep = function isDeep(prop) {
          return isObject(source[prop]) && target !== null && Object.prototype.hasOwnProperty.call(target, prop) && isObject(target[prop]);
        };
        var replaced = Object.getOwnPropertyNames(source).map(function (prop) {
          return _defineProperty({}, prop, isDeep(prop) ? mergeFn(target[prop], source[prop], deep) : source[prop]);
        }).reduce(function (a, b) {
          return _objectSpread$2(_objectSpread$2({}, a), b);
        }, {});
        return _objectSpread$2(_objectSpread$2({}, target), replaced);
      } else {
        return Object.assign(target, source);
      }
    };
    var merge = mergeFn;
    function isVueComponent(c) {
      return c && c.$ != null && c.$.vnode != null;
    }

    var mdiIcons = {
      sizes: {
        "default": 'mdi-24px',
        'is-small': null,
        'is-medium': 'mdi-36px',
        'is-large': 'mdi-48px'
      },
      iconPrefix: 'mdi-'
    };
    var faIcons = function faIcons() {
      var faIconPrefix = config && config.defaultIconComponent ? '' : 'fa-';
      return {
        sizes: {
          "default": null,
          'is-small': null,
          'is-medium': faIconPrefix + 'lg',
          'is-large': faIconPrefix + '2x'
        },
        iconPrefix: faIconPrefix,
        internalIcons: {
          information: 'info-circle',
          alert: 'exclamation-triangle',
          'alert-circle': 'exclamation-circle',
          'chevron-right': 'angle-right',
          'chevron-left': 'angle-left',
          'chevron-down': 'angle-down',
          'eye-off': 'eye-slash',
          'menu-down': 'caret-down',
          'menu-up': 'caret-up',
          'close-circle': 'times-circle'
        }
      };
    };
    var getIcons = function getIcons() {
      var icons = {
        mdi: mdiIcons,
        fa: faIcons(),
        fas: faIcons(),
        far: faIcons(),
        fad: faIcons(),
        fab: faIcons(),
        fal: faIcons(),
        'fa-solid': faIcons(),
        'fa-regular': faIcons(),
        'fa-light': faIcons(),
        'fa-thin': faIcons(),
        'fa-duotone': faIcons(),
        'fa-brands': faIcons()
      };
      if (config && config.customIconPacks) {
        icons = merge(icons, config.customIconPacks, true);
      }
      return icons;
    };
    var getIcons$1 = getIcons;

    var script$2 = {
        name: 'BIcon',
        props: {
            type: [String, Object],
            component: String,
            pack: String,
            icon: String,
            size: String,
            customSize: String,
            customClass: String,
            both: Boolean // This is used internally to show both MDI and FA icon
        },
        computed: {
            iconConfig() {
                const allIcons = getIcons$1();
                return allIcons[this.newPack]
            },
            iconPrefix() {
                if (this.iconConfig && this.iconConfig.iconPrefix) {
                    return this.iconConfig.iconPrefix
                }
                return ''
            },
            /**
            * Internal icon name based on the pack.
            * If pack is 'fa', gets the equivalent FA icon name of the MDI,
            * internal icons are always MDI.
            */
            newIcon() {
                return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`
            },
            newPack() {
                return this.pack || config.defaultIconPack
            },
            newType() {
                if (!this.type) return

                let splitType = [];
                if (typeof this.type === 'string') {
                    splitType = this.type.split('-');
                } else {
                    for (const key in this.type) {
                        if (this.type[key]) {
                            splitType = key.split('-');
                            break
                        }
                    }
                }
                if (splitType.length <= 1) return

                const [, ...type] = splitType;
                return `has-text-${type.join('-')}`
            },
            newCustomSize() {
                return this.customSize || this.customSizeByPack
            },
            customSizeByPack() {
                if (this.iconConfig && this.iconConfig.sizes) {
                    if (this.size && this.iconConfig.sizes[this.size] !== undefined) {
                        return this.iconConfig.sizes[this.size]
                    } else if (this.iconConfig.sizes.default) {
                        return this.iconConfig.sizes.default
                    }
                }
                return null
            },
            useIconComponent() {
                return this.component || config.defaultIconComponent
            }
        },
        methods: {
            /**
            * Equivalent icon name of the MDI.
            */
            getEquivalentIconOf(value) {
                // Only transform the class if the both prop is set to true
                if (!this.both) {
                    return value
                }

                if (this.iconConfig &&
                    this.iconConfig.internalIcons &&
                    this.iconConfig.internalIcons[value]) {
                    return this.iconConfig.internalIcons[value]
                }
                return value
            }
        }
    };

    function render$1(_ctx, _cache, $props, $setup, $data, $options) {
      return (vue.openBlock(), vue.createElementBlock("span", {
        class: vue.normalizeClass(["icon", [$options.newType, $props.size]])
      }, [
        (!$options.useIconComponent)
          ? (vue.openBlock(), vue.createElementBlock("i", {
              key: 0,
              class: vue.normalizeClass([$options.newPack, $options.newIcon, $options.newCustomSize, $props.customClass])
            }, null, 2 /* CLASS */))
          : (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent($options.useIconComponent), {
              key: 1,
              icon: [$options.newPack, $options.newIcon],
              size: $options.newCustomSize,
              class: vue.normalizeClass([$props.customClass])
            }, null, 8 /* PROPS */, ["icon", "size", "class"]))
      ], 2 /* CLASS */))
    }

    script$2.render = render$1;
    script$2.__file = "src/components/icon/Icon.vue";

    var _PatchFlagNames, _slotFlagsText;
    !!(process.env.NODE_ENV !== "production") ? Object.freeze({}) : {};
    !!(process.env.NODE_ENV !== "production") ? Object.freeze([]) : [];
    var cacheStringFunction = function cacheStringFunction(fn) {
      var cache = /* @__PURE__ */Object.create(null);
      return function (str) {
        var hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction(function (str) {
      return str.replace(camelizeRE, function (_, c) {
        return c ? c.toUpperCase() : "";
      });
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cacheStringFunction(function (str) {
      return str.replace(hyphenateRE, "-$1").toLowerCase();
    });
    var capitalize = cacheStringFunction(function (str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    var toHandlerKey = cacheStringFunction(function (str) {
      var s = str ? "on".concat(capitalize(str)) : "";
      return s;
    });
    (_PatchFlagNames = {}, _defineProperty(_PatchFlagNames, 1, "TEXT"), _defineProperty(_PatchFlagNames, 2, "CLASS"), _defineProperty(_PatchFlagNames, 4, "STYLE"), _defineProperty(_PatchFlagNames, 8, "PROPS"), _defineProperty(_PatchFlagNames, 16, "FULL_PROPS"), _defineProperty(_PatchFlagNames, 32, "HYDRATE_EVENTS"), _defineProperty(_PatchFlagNames, 64, "STABLE_FRAGMENT"), _defineProperty(_PatchFlagNames, 128, "KEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 256, "UNKEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 512, "NEED_PATCH"), _defineProperty(_PatchFlagNames, 1024, "DYNAMIC_SLOTS"), _defineProperty(_PatchFlagNames, 2048, "DEV_ROOT_FRAGMENT"), _defineProperty(_PatchFlagNames, -1, "HOISTED"), _defineProperty(_PatchFlagNames, -2, "BAIL"), _PatchFlagNames);
    (_slotFlagsText = {}, _defineProperty(_slotFlagsText, 1, "STABLE"), _defineProperty(_slotFlagsText, 2, "DYNAMIC"), _defineProperty(_slotFlagsText, 3, "FORWARDED"), _slotFlagsText);

    var SlotComponent = {
      name: 'BSlotComponent',
      props: {
        component: {
          type: Object,
          required: true
        },
        name: {
          type: String,
          "default": 'default'
        },
        scoped: {
          type: Boolean
        },
        props: {
          type: Object
        },
        tag: {
          type: String,
          "default": 'div'
        },
        event: {
          type: String,
          "default": 'vue:updated'
        }
      },
      data: function data() {
        return {
          updatedHook: undefined,
          handlerKey: undefined
        };
      },
      methods: {
        refresh: function refresh() {
          this.$forceUpdate();
        }
      },
      created: function created() {
        if (isVueComponent(this.component)) {
          if (this.event === 'vue:updated') {
            // lifecycle event cannot be captured as an ordinary event
            this.updatedHook = vue.onUpdated(this.refresh, this.component.$);
          } else {
            // directly manipuates the VNode
            // because Vue 3 no longer provides $on
            var vnode = this.component.$.vnode;
            var handlerKey = toHandlerKey(this.event);
            if (vnode.props == null) {
              vnode.props = _defineProperty({}, handlerKey, this.refresh);
            } else {
              var props = vnode.props;
              if (props[this.handlerKey] == null) {
                // tries camelCase
                handlerKey = toHandlerKey(camelize(this.event));
                if (props[handlerKey] == null) {
                  // tries kebab-case
                  handlerKey = toHandlerKey(hyphenate(this.event));
                }
              }
              if (props[handlerKey] == null) {
                handlerKey = toHandlerKey(this.event);
                props[handlerKey] = this.refresh;
              } else {
                // multiple handlers may be specified in an array
                if (Array.isArray(props[handlerKey])) {
                  props[handlerKey].push(this.refresh);
                } else {
                  props[handlerKey] = [props[handlerKey], this.refresh];
                }
              }
            }
            this.handlerKey = handlerKey;
          }
        }
      },
      beforeUnmount: function beforeUnmount() {
        if (isVueComponent(this.component)) {
          if (this.updatedHook != null) {
            // unfortunately, there is no counterpart of `onUpdated`.
            // so directly manipulates the internal instance.
            // see https://github.com/vuejs/core/blob/2ffe3d5b3e953b63d4743b1e2bc242d50916b545/packages/runtime-core/src/apiLifecycle.ts#L17-L64
            var index = this.component.$.u.indexOf(this.updatedHook);
            if (index !== -1) {
              this.component.$.u.splice(index, 1);
            }
          } else if (this.handlerKey != null) {
            // directly maniputates VNode
            // because Vue 3 no longer provides $off
            var props = this.component.$.vnode.props;
            if (props != null) {
              if (Array.isArray(props[this.handlerKey])) {
                var _index = props[this.handlerKey].indexOf(this.refresh);
                if (_index > -1) {
                  props[this.handlerKey].splice(_index, 1);
                  if (props[this.handlerKey].length === 1) {
                    props[this.handlerKey] = props[this.handlerKey][0];
                  }
                }
              } else {
                delete props[this.handlerKey];
              }
            }
          }
        }
      },
      render: function render() {
        return vue.h(this.tag, {}, this.component.$slots ? this.scoped ? this.component.$slots[this.name](this.props) : this.component.$slots[this.name]() : undefined);
      }
    };

    function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
    function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
    var items = 1;
    var sorted$1 = 3;
    var Sorted$1 = sorted$1;
    var ProviderParentMixin = (function (itemName) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var mixin = {
        provide: function provide() {
          return _defineProperty({}, 'b' + itemName, this);
        }
      };
      if (hasFlag(flags, items)) {
        mixin.data = function () {
          return _objectSpread$1({
            childItems: []
          }, hasFlag(flags, sorted$1) ? {
            nextIndex: 0
          } : {});
        };
        mixin.methods = {
          _registerItem: function _registerItem(item) {
            if (hasFlag(flags, sorted$1)) {
              // assigns a dynamic index.
              // dynamic indices will be messed up if any child is
              // unmounted.
              // use the new `order` prop to maintain the ordering.
              item.dynamicIndex = this.nextIndex;
              ++this.nextIndex;
            }
            this.childItems.push(item);
          },
          _unregisterItem: function _unregisterItem(item) {
            this.childItems = this.childItems.filter(function (i) {
              return i.uniqueValue !== item.uniqueValue;
            });
          }
        };
        if (hasFlag(flags, sorted$1)) {
          mixin.computed = {
            /**
             * When items are added/removed sort them according to their position
             */
            sortedItems: function sortedItems() {
              return this.childItems.slice().sort(function (i1, i2) {
                return i1.index - i2.index;
              });
            }
          };
        }
      }
      return mixin;
    });

    var TabbedMixin = (function (cmp) {
      var _components;
      return {
        mixins: [ProviderParentMixin(cmp, Sorted$1)],
        components: (_components = {}, _defineProperty(_components, script$2.name, script$2), _defineProperty(_components, SlotComponent.name, SlotComponent), _components),
        props: {
          modelValue: {
            type: [String, Number],
            "default": undefined
          },
          size: String,
          animated: {
            type: Boolean,
            "default": true
          },
          animation: String,
          animateInitially: Boolean,
          vertical: {
            type: Boolean,
            "default": false
          },
          position: String,
          destroyOnHide: {
            type: Boolean,
            "default": false
          }
        },
        emits: ['update:modelValue'],
        data: function data() {
          return {
            activeId: this.modelValue,
            // Internal state
            defaultSlots: [],
            contentHeight: 0,
            isTransitioning: false
          };
        },
        mounted: function mounted() {
          if (typeof this.modelValue === 'number') {
            // Backward compatibility: converts the index value to an id
            var value = bound(this.modelValue, 0, this.items.length - 1);
            this.activeId = this.items[value].uniqueValue;
          } else {
            this.activeId = this.modelValue;
          }
        },
        computed: {
          activeItem: function activeItem() {
            var _this = this;
            return this.activeId === undefined ? this.items[0] : this.activeId === null ? null : this.childItems.find(function (i) {
              return i.uniqueValue === _this.activeId;
            });
          },
          items: function items() {
            return this.sortedItems;
          }
        },
        watch: {
          /**
           * When v-model is changed set the new active tab.
           */
          modelValue: function modelValue(value) {
            if (typeof value === 'number') {
              // Backward compatibility: converts the index value to an id
              value = bound(value, 0, this.items.length - 1);
              this.activeId = this.items[value].uniqueValue;
            } else {
              this.activeId = value;
            }
          },
          /**
           * Sync internal state with external state
           */
          activeId: function activeId(val, oldValue) {
            var oldTab = oldValue !== undefined && oldValue !== null ? this.childItems.find(function (i) {
              return i.uniqueValue === oldValue;
            }) : null;
            if (oldTab && this.activeItem) {
              oldTab.deactivate(this.activeItem.index);
              this.activeItem.activate(oldTab.index);
            }
            val = this.activeItem ? typeof this.modelValue === 'number' ? this.items.indexOf(this.activeItem) : this.activeItem.uniqueValue : undefined;
            if (val !== this.modelValue) {
              this.$emit('update:modelValue', val);
            }
          }
        },
        methods: {
          /**
          * Child click listener, emit input event and change active child.
          */
          childClick: function childClick(child) {
            this.activeId = child.uniqueValue;
          },
          getNextItemIdx: function getNextItemIdx(fromIdx) {
            var skipDisabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var nextItemIdx = null;
            for (var i = 0; i < this.items.length; i++) {
              var item = this.items[i];
              if (fromIdx < item.index && item.visible && (!skipDisabled || skipDisabled && !item.disabled)) {
                nextItemIdx = item.index;
                break;
              }
            }
            return nextItemIdx;
          },
          getPrevItemIdx: function getPrevItemIdx(fromIdx) {
            var skipDisabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var prevItemIdx = null;
            for (var i = this.items.length - 1; i >= 0; i--) {
              var item = this.items[i];
              if (item.index < fromIdx && item.visible && (!skipDisabled || skipDisabled && !item.disabled)) {
                prevItemIdx = item.index;
                break;
              }
            }
            return prevItemIdx;
          }
        }
      };
    });

    var script$1 = {
        name: 'BSteps',
        components: {
            [script$2.name]: script$2
        },
        mixins: [TabbedMixin('step')],
        props: {
            type: [String, Object],
            iconPack: String,
            iconPrev: {
                type: String,
                default: () => {
                    return config.defaultIconPrev
                }
            },
            iconNext: {
                type: String,
                default: () => {
                    return config.defaultIconNext
                }
            },
            hasNavigation: {
                type: Boolean,
                default: true
            },
            labelPosition: {
                type: String,
                validator(value) {
                    return [
                        'bottom',
                        'right',
                        'left'
                    ].indexOf(value) > -1
                },
                default: 'bottom'
            },
            rounded: {
                type: Boolean,
                default: true
            },
            mobileMode: {
                type: String,
                validator(value) {
                    return [
                        'minimalist',
                        'compact'
                    ].indexOf(value) > -1
                },
                default: 'minimalist'
            },
            ariaNextLabel: String,
            ariaPreviousLabel: String
        },
        computed: {
            // Override mixin implementation to always have a value
            activeItem() {
                return this.childItems.filter((i) => i.uniqueValue === this.activeId)[0] ||
                    this.items[0]
            },
            wrapperClasses() {
                return [
                    this.size,
                    {
                        'is-vertical': this.vertical,
                        [this.position]: this.position && this.vertical
                    }
                ]
            },
            mainClasses() {
                return [
                    this.type,
                    {
                        'has-label-right': this.labelPosition === 'right',
                        'has-label-left': this.labelPosition === 'left',
                        'is-animated': this.animated,
                        'is-rounded': this.rounded,
                        [`mobile-${this.mobileMode}`]: this.mobileMode !== null
                    }
                ]
            },

            /**
             * Check if previous button is available.
             */
            hasPrev() {
                return this.prevItemIdx !== null
            },

            /**
             * Retrieves the next visible item index
             */
            nextItemIdx() {
                const idx = this.activeItem ? this.activeItem.index : 0;
                return this.getNextItemIdx(idx)
            },

            /**
             * Retrieves the next visible item
             */
            nextItem() {
                let nextItem = null;
                if (this.nextItemIdx !== null) {
                    nextItem = this.items.find((i) => i.index === this.nextItemIdx);
                }
                return nextItem
            },

            /**
            * Retrieves the next visible item index
            */
            prevItemIdx() {
                if (!this.activeItem) { return null }
                const idx = this.activeItem.index;
                return this.getPrevItemIdx(idx)
            },

            /**
             * Retrieves the previous visible item
             */
            prevItem() {
                if (!this.activeItem) { return null }

                let prevItem = null;
                if (this.prevItemIdx !== null) {
                    prevItem = this.items.find((i) => i.index === this.prevItemIdx);
                }
                return prevItem
            },

            /**
             * Check if next button is available.
             */
            hasNext() {
                return this.nextItemIdx !== null
            },

            navigationProps() {
                return {
                    previous: {
                        disabled: !this.hasPrev,
                        action: this.prev
                    },
                    next: {
                        disabled: !this.hasNext,
                        action: this.next
                    }
                }
            }
        },
        methods: {
            /**
             * Return if the step should be clickable or not.
             */
            isItemClickable(stepItem) {
                if (stepItem.clickable === undefined) {
                    return stepItem.index < this.activeItem.index
                }
                return stepItem.clickable
            },

            /**
             * Previous button click listener.
             */
            prev() {
                if (this.hasPrev) {
                    this.activeId = this.prevItem.uniqueValue;
                }
            },

            /**
             * Previous button click listener.
             */
            next() {
                if (this.hasNext) {
                    this.activeId = this.nextItem.uniqueValue;
                }
            }
        }
    };

    const _hoisted_1 = { class: "step-items" };
    const _hoisted_2 = ["onClick"];
    const _hoisted_3 = { class: "step-marker" };
    const _hoisted_4 = { key: 1 };
    const _hoisted_5 = { class: "step-details" };
    const _hoisted_6 = { class: "step-title" };
    const _hoisted_7 = {
      key: 0,
      class: "step-navigation"
    };
    const _hoisted_8 = ["disabled", "aria-label"];
    const _hoisted_9 = ["disabled", "aria-label"];

    function render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_b_icon = vue.resolveComponent("b-icon");

      return (vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["b-steps", $options.wrapperClasses])
      }, [
        vue.createElementVNode("nav", {
          class: vue.normalizeClass(["steps", $options.mainClasses])
        }, [
          vue.createElementVNode("ul", _hoisted_1, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.items, (childItem) => {
              return vue.withDirectives((vue.openBlock(), vue.createElementBlock("li", {
                key: childItem.uniqueValue,
                class: vue.normalizeClass(["step-item", [childItem.type || $props.type, childItem.headerClass, {
                            'is-active': childItem.isActive,
                            'is-previous': $options.activeItem.index > childItem.index
                        }]])
              }, [
                vue.createElementVNode("a", {
                  class: vue.normalizeClass(["step-link", {'is-clickable': $options.isItemClickable(childItem)}]),
                  onClick: $event => ($options.isItemClickable(childItem) && _ctx.childClick(childItem))
                }, [
                  vue.createElementVNode("div", _hoisted_3, [
                    (childItem.icon)
                      ? (vue.openBlock(), vue.createBlock(_component_b_icon, {
                          key: 0,
                          icon: childItem.icon,
                          pack: childItem.iconPack,
                          size: _ctx.size
                        }, null, 8 /* PROPS */, ["icon", "pack", "size"]))
                      : (childItem.step)
                        ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_4, vue.toDisplayString(childItem.step), 1 /* TEXT */))
                        : vue.createCommentVNode("v-if", true)
                  ]),
                  vue.createElementVNode("div", _hoisted_5, [
                    vue.createElementVNode("span", _hoisted_6, vue.toDisplayString(childItem.label), 1 /* TEXT */)
                  ])
                ], 10 /* CLASS, PROPS */, _hoisted_2)
              ], 2 /* CLASS */)), [
                [vue.vShow, childItem.visible]
              ])
            }), 128 /* KEYED_FRAGMENT */))
          ])
        ], 2 /* CLASS */),
        vue.createElementVNode("section", {
          class: vue.normalizeClass(["step-content", {'is-transitioning': _ctx.isTransitioning}])
        }, [
          vue.renderSlot(_ctx.$slots, "default")
        ], 2 /* CLASS */),
        vue.renderSlot(_ctx.$slots, "navigation", {
          previous: $options.navigationProps.previous,
          next: $options.navigationProps.next
        }, () => [
          ($props.hasNavigation)
            ? (vue.openBlock(), vue.createElementBlock("nav", _hoisted_7, [
                vue.createElementVNode("a", {
                  role: "button",
                  class: "pagination-previous",
                  disabled: $options.navigationProps.previous.disabled || undefined,
                  onClick: _cache[0] || (_cache[0] = vue.withModifiers((...args) => ($options.navigationProps.previous.action && $options.navigationProps.previous.action(...args)), ["prevent"])),
                  "aria-label": $props.ariaPreviousLabel
                }, [
                  vue.createVNode(_component_b_icon, {
                    icon: $props.iconPrev,
                    pack: $props.iconPack,
                    both: "",
                    "aria-hidden": "true"
                  }, null, 8 /* PROPS */, ["icon", "pack"])
                ], 8 /* PROPS */, _hoisted_8),
                vue.createElementVNode("a", {
                  role: "button",
                  class: "pagination-next",
                  disabled: $options.navigationProps.next.disabled || undefined,
                  onClick: _cache[1] || (_cache[1] = vue.withModifiers((...args) => ($options.navigationProps.next.action && $options.navigationProps.next.action(...args)), ["prevent"])),
                  "aria-label": $props.ariaNextLabel
                }, [
                  vue.createVNode(_component_b_icon, {
                    icon: $props.iconNext,
                    pack: $props.iconPack,
                    both: "",
                    "aria-hidden": "true"
                  }, null, 8 /* PROPS */, ["icon", "pack"])
                ], 8 /* PROPS */, _hoisted_9)
              ]))
            : vue.createCommentVNode("v-if", true)
        ])
      ], 2 /* CLASS */))
    }

    script$1.render = render;
    script$1.__file = "src/components/steps/Steps.vue";

    function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
    function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
    var sorted = 1;
    var optional = 2;
    var Sorted = sorted;
    var InjectedChildMixin = (function (parentItemName) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var mixin = {
        inject: {
          parent: {
            from: 'b' + parentItemName,
            "default": false
          }
        },
        props: {
          // if `value` is non-null, it must be unique among all the siblings.
          // see `uniqueValue`
          value: {
            type: String,
            "default": null
          }
        },
        computed: {
          // `ProviderParentMixin` uses `uniqueValue` computed value to
          // identify the child in its `childItems` collection.
          // so the value must be unique among all the siblings.
          // falls back to the `uid` internal field to ensure uniqueness.
          uniqueValue: function uniqueValue() {
            return this.value != null ? this.value : this.$.uid;
          }
        },
        created: function created() {
          if (!this.parent) {
            if (!hasFlag(flags, optional)) {
              throw new Error('You should wrap ' + this.$options.name + ' in a ' + parentItemName);
            }
          } else if (this.parent._registerItem) {
            this.parent._registerItem(this);
          }
        },
        beforeUnmount: function beforeUnmount() {
          if (this.parent && this.parent._unregisterItem) {
            this.parent._unregisterItem(this);
          }
        }
      };
      if (hasFlag(flags, sorted)) {
        // a user can explicitly specify the `order` prop to keep the order of
        // children.
        // I can no longer rely on automatic indexing of children, because I
        // could not figure out how to calculate the index of a child in its
        // parent on Vue 3.
        // incomplete dynamic indexing is still available if any child is never
        // unmounted; e.g., not switched with `v-if`
        mixin.props = _objectSpread(_objectSpread({}, mixin.props), {}, {
          order: {
            type: Number,
            required: false
          }
        });
        mixin.data = function () {
          return {
            dynamicIndex: null
          };
        };
        mixin.computed = _objectSpread(_objectSpread({}, mixin.computed), {}, {
          index: function index() {
            return this.order != null ? this.order : this.dynamicIndex;
          }
        });
      }
      return mixin;
    });

    var TabbedChildMixin = (function (parentCmp) {
      return {
        mixins: [InjectedChildMixin(parentCmp, Sorted)],
        props: {
          label: String,
          icon: String,
          iconPack: String,
          visible: {
            type: Boolean,
            "default": true
          },
          headerClass: {
            type: [String, Array, Object],
            "default": null
          }
        },
        data: function data() {
          return {
            transitionName: null,
            elementClass: 'item',
            elementRole: null
          };
        },
        computed: {
          isActive: function isActive() {
            return this.parent.activeItem === this;
          }
        },
        methods: {
          /**
           * Activate element, alter animation name based on the index.
           */
          activate: function activate(oldIndex) {
            this.transitionName = this.index < oldIndex ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
          },
          /**
           * Deactivate element, alter animation name based on the index.
           */
          deactivate: function deactivate(newIndex) {
            this.transitionName = newIndex < this.index ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
          }
        },
        render: function render() {
          var _this = this;
          // if destroy apply v-if
          if (this.parent.destroyOnHide) {
            if (!this.isActive || !this.visible) {
              return;
            }
          }
          var vnode = vue.withDirectives(vue.h('div', {
            // NOTE: possible regression of #3272
            // https://github.com/buefy/buefy/issues/3272
            "class": this.elementClass,
            role: this.elementRole,
            id: "".concat(this.uniqueValue, "-content"),
            'aria-labelledby': this.elementRole ? "".concat(this.uniqueValue, "-label") : null,
            tabindex: this.isActive ? 0 : -1
          }, this.$slots), [[vue.vShow, this.isActive && this.visible]]);
          // check animated prop
          if (this.parent.animated) {
            return vue.h(vue.Transition, {
              name: this.parent.animation || this.transitionName,
              appear: this.parent.animateInitially === true || undefined,
              onBeforeEnter: function onBeforeEnter() {
                _this.parent.isTransitioning = true;
              },
              onAfterEnter: function onAfterEnter() {
                _this.parent.isTransitioning = false;
              }
            }, {
              "default": function _default() {
                return vnode;
              }
            });
          }
          return vnode;
        }
      };
    });

    var script = {
        name: 'BStepItem',
        mixins: [TabbedChildMixin('step')],
        props: {
            step: [String, Number],
            type: [String, Object],
            clickable: {
                type: Boolean,
                default: undefined
            }
        },
        data() {
            return {
                elementClass: 'step-item'
            }
        }
    };

    script.__file = "src/components/steps/StepItem.vue";

    var use = function use(plugin) {
      if (typeof window !== 'undefined' && window.Vue) {
        window.Vue.use(plugin);
      }
    };

    // use `name` to register a Functional Component which will become unresolvable
    // in production build due to name mangling.
    var registerComponent = function registerComponent(Vue, component, name) {
      Vue.component(name || component.name, component);
    };

    var Plugin = {
      install: function install(Vue) {
        registerComponent(Vue, script$1);
        registerComponent(Vue, script);
      }
    };
    use(Plugin);

    exports.BStepItem = script;
    exports.BSteps = script$1;
    exports.default = Plugin;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
